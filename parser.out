Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABS
    ARRAY
    BOOL
    COMMENT
    DECLARE
    LEFT_CUR_PAR
    LEFT_SQ_PAR
    MOD
    NULL
    OF
    POW
    REVERSE
    RIGHT_CUR_PAR
    RIGHT_SQ_PAR
    XOR

Grammar

Rule 0     S' -> prog
Rule 1     empty -> <empty>
Rule 2     prog -> subprogram
Rule 3     prog -> headers subprogram
Rule 4     headers -> headers header
Rule 5     headers -> header
Rule 6     header -> WITH pkg SEMICOLON
Rule 7     header -> WITH pkg SEMICOLON USE pkg SEMICOLON
Rule 8     pkg -> pkg DOT IDENT
Rule 9     pkg -> IDENT
Rule 10    subprogram -> procedure
Rule 11    subprogram -> function
Rule 12    function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
Rule 13    function_call -> IDENT LEFT_PAR value RIGHT_PAR
Rule 14    procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
Rule 15    args_opt -> LEFT_PAR args RIGHT_PAR
Rule 16    args_opt -> empty
Rule 17    args -> args COMMA arg
Rule 18    args -> arg
Rule 19    arg -> IDENT COLON type
Rule 20    type -> TYPE_INT
Rule 21    type -> TYPE_FLOAT
Rule 22    type -> TYPE_BOOL
Rule 23    declarations -> declarations declaration
Rule 24    declarations -> declaration
Rule 25    declaration -> empty
Rule 26    declaration -> function
Rule 27    declaration -> procedure
Rule 28    declaration -> IDENT COLON type ASSIGN value SEMICOLON
Rule 29    value -> expr
Rule 30    value -> bool_expr
Rule 31    expr -> expr PLUS term
Rule 32    expr -> expr MINUS term
Rule 33    expr -> term
Rule 34    term -> term MUL factor
Rule 35    term -> term DIV factor
Rule 36    term -> factor
Rule 37    factor -> LEFT_PAR expr RIGHT_PAR
Rule 38    factor -> function_call
Rule 39    factor -> IDENT
Rule 40    factor -> NUMBER
Rule 41    bool_expr -> bool_term AND bool_term
Rule 42    bool_expr -> bool_term OR bool_term
Rule 43    bool_expr -> bool_term
Rule 44    bool_term -> NOT bool
Rule 45    bool_term -> bool
Rule 46    bool -> LEFT_PAR bool_expr RIGHT_PAR
Rule 47    bool -> BOOL_VAL
Rule 48    bool -> IDENT
Rule 49    bool -> rel_operand rel_operator rel_operand
Rule 50    rel_operand -> NUMBER
Rule 51    rel_operand -> IDENT
Rule 52    rel_operator -> EQUALS
Rule 53    rel_operator -> NOT_EQUALS
Rule 54    rel_operator -> GREATER
Rule 55    rel_operator -> LESS
Rule 56    rel_operator -> GTEQ
Rule 57    rel_operator -> LSEQ
Rule 58    statements -> statements statement
Rule 59    statements -> statement
Rule 60    statement -> assign
Rule 61    statement -> if
Rule 62    statement -> loop
Rule 63    statement -> put_line
Rule 64    statement -> function_call SEMICOLON
Rule 65    ret_statements -> ret_statements ret_statement
Rule 66    ret_statements -> ret_statement
Rule 67    ret_statement -> statement
Rule 68    ret_statement -> RETURN value SEMICOLON
Rule 69    assign -> IDENT ASSIGN value SEMICOLON
Rule 70    if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
Rule 71    elsifs -> elsifs elsif
Rule 72    elsifs -> empty
Rule 73    elsif -> ELSIF bool_expr THEN ret_statements
Rule 74    else -> ELSE ret_statements
Rule 75    else -> empty
Rule 76    loop -> loop_body
Rule 77    loop -> for_range loop_body
Rule 78    loop -> while loop_body
Rule 79    loop_body -> LOOP statements END LOOP SEMICOLON
Rule 80    for_range -> FOR IDENT IN expr DUB_DOT expr
Rule 81    while -> WHILE bool_expr
Rule 82    put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
Rule 83    str_expr -> str_expr AMPERSAND str_term
Rule 84    str_expr -> str_term
Rule 85    str_term -> STRING
Rule 86    str_term -> type APOSTROPHE IMAGE LEFT_PAR value RIGHT_PAR

Terminals, with rules where they appear

ABS                  : 
AMPERSAND            : 83
AND                  : 41
APOSTROPHE           : 86
ARRAY                : 
ASSIGN               : 28 69
BEGIN                : 12 14
BOOL                 : 
BOOL_VAL             : 47
COLON                : 19 28
COMMA                : 17
COMMENT              : 
DECLARE              : 
DIV                  : 35
DOT                  : 8
DUB_DOT              : 80
ELSE                 : 74
ELSIF                : 73
END                  : 12 14 70 79
EQUALS               : 52
FOR                  : 80
FUNC                 : 12
GREATER              : 54
GTEQ                 : 56
IDENT                : 8 9 12 12 13 14 14 19 28 39 48 51 69 80
IF                   : 70 70
IMAGE                : 86
IN                   : 80
IS                   : 12 14
LEFT_CUR_PAR         : 
LEFT_PAR             : 13 15 37 46 82 86
LEFT_SQ_PAR          : 
LESS                 : 55
LOOP                 : 79 79
LSEQ                 : 57
MINUS                : 32
MOD                  : 
MUL                  : 34
NOT                  : 44
NOT_EQUALS           : 53
NULL                 : 
NUMBER               : 40 50
OF                   : 
OR                   : 42
PLUS                 : 31
POW                  : 
PROC                 : 14
PUT_LINE             : 82
RETURN               : 12 68
REVERSE              : 
RIGHT_CUR_PAR        : 
RIGHT_PAR            : 13 15 37 46 82 86
RIGHT_SQ_PAR         : 
SEMICOLON            : 6 7 7 12 14 28 64 68 69 70 79 82
STRING               : 85
THEN                 : 70 73
TYPE_BOOL            : 22
TYPE_FLOAT           : 21
TYPE_INT             : 20
USE                  : 7
WHILE                : 81
WITH                 : 6 7
XOR                  : 
error                : 

Nonterminals, with rules where they appear

arg                  : 17 18
args                 : 15 17
args_opt             : 12 14
assign               : 60
bool                 : 44 45
bool_expr            : 30 46 70 73 81
bool_term            : 41 41 42 42 43
declaration          : 23 24
declarations         : 12 14 23
else                 : 70
elsif                : 71
elsifs               : 70 71
empty                : 16 25 72 75
expr                 : 29 31 32 37 80 80
factor               : 34 35 36
for_range            : 77
function             : 11 26
function_call        : 38 64
header               : 4 5
headers              : 3 4
if                   : 61
loop                 : 62
loop_body            : 76 77 78
pkg                  : 6 7 7 8
procedure            : 10 27
prog                 : 0
put_line             : 63
rel_operand          : 49 49
rel_operator         : 49
ret_statement        : 65 66
ret_statements       : 12 65 70 73 74
statement            : 58 59 67
statements           : 14 58 79
str_expr             : 82 83
str_term             : 83 84
subprogram           : 2 3
term                 : 31 32 33 34 35
type                 : 12 19 28 86
value                : 13 28 68 69 86
while                : 78

Parsing method: LALR

state 0

    (0) S' -> . prog
    (2) prog -> . subprogram
    (3) prog -> . headers subprogram
    (10) subprogram -> . procedure
    (11) subprogram -> . function
    (4) headers -> . headers header
    (5) headers -> . header
    (14) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (6) header -> . WITH pkg SEMICOLON
    (7) header -> . WITH pkg SEMICOLON USE pkg SEMICOLON

    PROC            shift and go to state 7
    FUNC            shift and go to state 8
    WITH            shift and go to state 9

    prog                           shift and go to state 1
    subprogram                     shift and go to state 2
    headers                        shift and go to state 3
    procedure                      shift and go to state 4
    function                       shift and go to state 5
    header                         shift and go to state 6

state 1

    (0) S' -> prog .



state 2

    (2) prog -> subprogram .

    $end            reduce using rule 2 (prog -> subprogram .)


state 3

    (3) prog -> headers . subprogram
    (4) headers -> headers . header
    (10) subprogram -> . procedure
    (11) subprogram -> . function
    (6) header -> . WITH pkg SEMICOLON
    (7) header -> . WITH pkg SEMICOLON USE pkg SEMICOLON
    (14) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON

    WITH            shift and go to state 9
    PROC            shift and go to state 7
    FUNC            shift and go to state 8

    subprogram                     shift and go to state 10
    header                         shift and go to state 11
    procedure                      shift and go to state 4
    function                       shift and go to state 5

state 4

    (10) subprogram -> procedure .

    $end            reduce using rule 10 (subprogram -> procedure .)


state 5

    (11) subprogram -> function .

    $end            reduce using rule 11 (subprogram -> function .)


state 6

    (5) headers -> header .

    WITH            reduce using rule 5 (headers -> header .)
    PROC            reduce using rule 5 (headers -> header .)
    FUNC            reduce using rule 5 (headers -> header .)


state 7

    (14) procedure -> PROC . IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

    IDENT           shift and go to state 12


state 8

    (12) function -> FUNC . IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON

    IDENT           shift and go to state 13


state 9

    (6) header -> WITH . pkg SEMICOLON
    (7) header -> WITH . pkg SEMICOLON USE pkg SEMICOLON
    (8) pkg -> . pkg DOT IDENT
    (9) pkg -> . IDENT

    IDENT           shift and go to state 15

    pkg                            shift and go to state 14

state 10

    (3) prog -> headers subprogram .

    $end            reduce using rule 3 (prog -> headers subprogram .)


state 11

    (4) headers -> headers header .

    WITH            reduce using rule 4 (headers -> headers header .)
    PROC            reduce using rule 4 (headers -> headers header .)
    FUNC            reduce using rule 4 (headers -> headers header .)


state 12

    (14) procedure -> PROC IDENT . args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (15) args_opt -> . LEFT_PAR args RIGHT_PAR
    (16) args_opt -> . empty
    (1) empty -> .

    LEFT_PAR        shift and go to state 17
    IS              reduce using rule 1 (empty -> .)

    args_opt                       shift and go to state 16
    empty                          shift and go to state 18

state 13

    (12) function -> FUNC IDENT . args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (15) args_opt -> . LEFT_PAR args RIGHT_PAR
    (16) args_opt -> . empty
    (1) empty -> .

    LEFT_PAR        shift and go to state 17
    RETURN          reduce using rule 1 (empty -> .)

    args_opt                       shift and go to state 19
    empty                          shift and go to state 18

state 14

    (6) header -> WITH pkg . SEMICOLON
    (7) header -> WITH pkg . SEMICOLON USE pkg SEMICOLON
    (8) pkg -> pkg . DOT IDENT

    SEMICOLON       shift and go to state 20
    DOT             shift and go to state 21


state 15

    (9) pkg -> IDENT .

    SEMICOLON       reduce using rule 9 (pkg -> IDENT .)
    DOT             reduce using rule 9 (pkg -> IDENT .)


state 16

    (14) procedure -> PROC IDENT args_opt . IS declarations BEGIN statements END IDENT SEMICOLON

    IS              shift and go to state 22


state 17

    (15) args_opt -> LEFT_PAR . args RIGHT_PAR
    (17) args -> . args COMMA arg
    (18) args -> . arg
    (19) arg -> . IDENT COLON type

    IDENT           shift and go to state 25

    args                           shift and go to state 23
    arg                            shift and go to state 24

state 18

    (16) args_opt -> empty .

    IS              reduce using rule 16 (args_opt -> empty .)
    RETURN          reduce using rule 16 (args_opt -> empty .)


state 19

    (12) function -> FUNC IDENT args_opt . RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON

    RETURN          shift and go to state 26


state 20

    (6) header -> WITH pkg SEMICOLON .
    (7) header -> WITH pkg SEMICOLON . USE pkg SEMICOLON

    WITH            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    PROC            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    FUNC            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    USE             shift and go to state 27


state 21

    (8) pkg -> pkg DOT . IDENT

    IDENT           shift and go to state 28


state 22

    (14) procedure -> PROC IDENT args_opt IS . declarations BEGIN statements END IDENT SEMICOLON
    (23) declarations -> . declarations declaration
    (24) declarations -> . declaration
    (25) declaration -> . empty
    (26) declaration -> . function
    (27) declaration -> . procedure
    (28) declaration -> . IDENT COLON type ASSIGN value SEMICOLON
    (1) empty -> .
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (14) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PROC resolved as shift
    IDENT           shift and go to state 29
    BEGIN           reduce using rule 1 (empty -> .)
    FUNC            shift and go to state 8
    PROC            shift and go to state 7

  ! IDENT           [ reduce using rule 1 (empty -> .) ]
  ! FUNC            [ reduce using rule 1 (empty -> .) ]
  ! PROC            [ reduce using rule 1 (empty -> .) ]

    declarations                   shift and go to state 30
    declaration                    shift and go to state 31
    empty                          shift and go to state 32
    function                       shift and go to state 33
    procedure                      shift and go to state 34

state 23

    (15) args_opt -> LEFT_PAR args . RIGHT_PAR
    (17) args -> args . COMMA arg

    RIGHT_PAR       shift and go to state 35
    COMMA           shift and go to state 36


state 24

    (18) args -> arg .

    RIGHT_PAR       reduce using rule 18 (args -> arg .)
    COMMA           reduce using rule 18 (args -> arg .)


state 25

    (19) arg -> IDENT . COLON type

    COLON           shift and go to state 37


state 26

    (12) function -> FUNC IDENT args_opt RETURN . type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (20) type -> . TYPE_INT
    (21) type -> . TYPE_FLOAT
    (22) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 39
    TYPE_FLOAT      shift and go to state 40
    TYPE_BOOL       shift and go to state 41

    type                           shift and go to state 38

state 27

    (7) header -> WITH pkg SEMICOLON USE . pkg SEMICOLON
    (8) pkg -> . pkg DOT IDENT
    (9) pkg -> . IDENT

    IDENT           shift and go to state 15

    pkg                            shift and go to state 42

state 28

    (8) pkg -> pkg DOT IDENT .

    SEMICOLON       reduce using rule 8 (pkg -> pkg DOT IDENT .)
    DOT             reduce using rule 8 (pkg -> pkg DOT IDENT .)


state 29

    (28) declaration -> IDENT . COLON type ASSIGN value SEMICOLON

    COLON           shift and go to state 43


state 30

    (14) procedure -> PROC IDENT args_opt IS declarations . BEGIN statements END IDENT SEMICOLON
    (23) declarations -> declarations . declaration
    (25) declaration -> . empty
    (26) declaration -> . function
    (27) declaration -> . procedure
    (28) declaration -> . IDENT COLON type ASSIGN value SEMICOLON
    (1) empty -> .
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (14) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PROC resolved as shift
    BEGIN           shift and go to state 44
    IDENT           shift and go to state 29
    FUNC            shift and go to state 8
    PROC            shift and go to state 7

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! IDENT           [ reduce using rule 1 (empty -> .) ]
  ! FUNC            [ reduce using rule 1 (empty -> .) ]
  ! PROC            [ reduce using rule 1 (empty -> .) ]

    declaration                    shift and go to state 45
    empty                          shift and go to state 32
    function                       shift and go to state 33
    procedure                      shift and go to state 34

state 31

    (24) declarations -> declaration .

    BEGIN           reduce using rule 24 (declarations -> declaration .)
    IDENT           reduce using rule 24 (declarations -> declaration .)
    FUNC            reduce using rule 24 (declarations -> declaration .)
    PROC            reduce using rule 24 (declarations -> declaration .)


state 32

    (25) declaration -> empty .

    BEGIN           reduce using rule 25 (declaration -> empty .)
    IDENT           reduce using rule 25 (declaration -> empty .)
    FUNC            reduce using rule 25 (declaration -> empty .)
    PROC            reduce using rule 25 (declaration -> empty .)


state 33

    (26) declaration -> function .

    BEGIN           reduce using rule 26 (declaration -> function .)
    IDENT           reduce using rule 26 (declaration -> function .)
    FUNC            reduce using rule 26 (declaration -> function .)
    PROC            reduce using rule 26 (declaration -> function .)


state 34

    (27) declaration -> procedure .

    BEGIN           reduce using rule 27 (declaration -> procedure .)
    IDENT           reduce using rule 27 (declaration -> procedure .)
    FUNC            reduce using rule 27 (declaration -> procedure .)
    PROC            reduce using rule 27 (declaration -> procedure .)


state 35

    (15) args_opt -> LEFT_PAR args RIGHT_PAR .

    IS              reduce using rule 15 (args_opt -> LEFT_PAR args RIGHT_PAR .)
    RETURN          reduce using rule 15 (args_opt -> LEFT_PAR args RIGHT_PAR .)


state 36

    (17) args -> args COMMA . arg
    (19) arg -> . IDENT COLON type

    IDENT           shift and go to state 25

    arg                            shift and go to state 46

state 37

    (19) arg -> IDENT COLON . type
    (20) type -> . TYPE_INT
    (21) type -> . TYPE_FLOAT
    (22) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 39
    TYPE_FLOAT      shift and go to state 40
    TYPE_BOOL       shift and go to state 41

    type                           shift and go to state 47

state 38

    (12) function -> FUNC IDENT args_opt RETURN type . IS declarations BEGIN ret_statements END IDENT SEMICOLON

    IS              shift and go to state 48


state 39

    (20) type -> TYPE_INT .

    IS              reduce using rule 20 (type -> TYPE_INT .)
    RIGHT_PAR       reduce using rule 20 (type -> TYPE_INT .)
    COMMA           reduce using rule 20 (type -> TYPE_INT .)
    ASSIGN          reduce using rule 20 (type -> TYPE_INT .)
    APOSTROPHE      reduce using rule 20 (type -> TYPE_INT .)


state 40

    (21) type -> TYPE_FLOAT .

    IS              reduce using rule 21 (type -> TYPE_FLOAT .)
    RIGHT_PAR       reduce using rule 21 (type -> TYPE_FLOAT .)
    COMMA           reduce using rule 21 (type -> TYPE_FLOAT .)
    ASSIGN          reduce using rule 21 (type -> TYPE_FLOAT .)
    APOSTROPHE      reduce using rule 21 (type -> TYPE_FLOAT .)


state 41

    (22) type -> TYPE_BOOL .

    IS              reduce using rule 22 (type -> TYPE_BOOL .)
    RIGHT_PAR       reduce using rule 22 (type -> TYPE_BOOL .)
    COMMA           reduce using rule 22 (type -> TYPE_BOOL .)
    ASSIGN          reduce using rule 22 (type -> TYPE_BOOL .)
    APOSTROPHE      reduce using rule 22 (type -> TYPE_BOOL .)


state 42

    (7) header -> WITH pkg SEMICOLON USE pkg . SEMICOLON
    (8) pkg -> pkg . DOT IDENT

    SEMICOLON       shift and go to state 49
    DOT             shift and go to state 21


state 43

    (28) declaration -> IDENT COLON . type ASSIGN value SEMICOLON
    (20) type -> . TYPE_INT
    (21) type -> . TYPE_FLOAT
    (22) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 39
    TYPE_FLOAT      shift and go to state 40
    TYPE_BOOL       shift and go to state 41

    type                           shift and go to state 50

state 44

    (14) procedure -> PROC IDENT args_opt IS declarations BEGIN . statements END IDENT SEMICOLON
    (58) statements -> . statements statement
    (59) statements -> . statement
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    statements                     shift and go to state 52
    statement                      shift and go to state 53
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 45

    (23) declarations -> declarations declaration .

    BEGIN           reduce using rule 23 (declarations -> declarations declaration .)
    IDENT           reduce using rule 23 (declarations -> declarations declaration .)
    FUNC            reduce using rule 23 (declarations -> declarations declaration .)
    PROC            reduce using rule 23 (declarations -> declarations declaration .)


state 46

    (17) args -> args COMMA arg .

    RIGHT_PAR       reduce using rule 17 (args -> args COMMA arg .)
    COMMA           reduce using rule 17 (args -> args COMMA arg .)


state 47

    (19) arg -> IDENT COLON type .

    RIGHT_PAR       reduce using rule 19 (arg -> IDENT COLON type .)
    COMMA           reduce using rule 19 (arg -> IDENT COLON type .)


state 48

    (12) function -> FUNC IDENT args_opt RETURN type IS . declarations BEGIN ret_statements END IDENT SEMICOLON
    (23) declarations -> . declarations declaration
    (24) declarations -> . declaration
    (25) declaration -> . empty
    (26) declaration -> . function
    (27) declaration -> . procedure
    (28) declaration -> . IDENT COLON type ASSIGN value SEMICOLON
    (1) empty -> .
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (14) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PROC resolved as shift
    IDENT           shift and go to state 29
    BEGIN           reduce using rule 1 (empty -> .)
    FUNC            shift and go to state 8
    PROC            shift and go to state 7

  ! IDENT           [ reduce using rule 1 (empty -> .) ]
  ! FUNC            [ reduce using rule 1 (empty -> .) ]
  ! PROC            [ reduce using rule 1 (empty -> .) ]

    declarations                   shift and go to state 67
    declaration                    shift and go to state 31
    empty                          shift and go to state 32
    function                       shift and go to state 33
    procedure                      shift and go to state 34

state 49

    (7) header -> WITH pkg SEMICOLON USE pkg SEMICOLON .

    WITH            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)
    PROC            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)
    FUNC            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)


state 50

    (28) declaration -> IDENT COLON type . ASSIGN value SEMICOLON

    ASSIGN          shift and go to state 68


state 51

    (69) assign -> IDENT . ASSIGN value SEMICOLON
    (13) function_call -> IDENT . LEFT_PAR value RIGHT_PAR

    ASSIGN          shift and go to state 69
    LEFT_PAR        shift and go to state 70


state 52

    (14) procedure -> PROC IDENT args_opt IS declarations BEGIN statements . END IDENT SEMICOLON
    (58) statements -> statements . statement
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    END             shift and go to state 71
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    statement                      shift and go to state 72
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 53

    (59) statements -> statement .

    END             reduce using rule 59 (statements -> statement .)
    IDENT           reduce using rule 59 (statements -> statement .)
    IF              reduce using rule 59 (statements -> statement .)
    PUT_LINE        reduce using rule 59 (statements -> statement .)
    LOOP            reduce using rule 59 (statements -> statement .)
    FOR             reduce using rule 59 (statements -> statement .)
    WHILE           reduce using rule 59 (statements -> statement .)


state 54

    (60) statement -> assign .

    END             reduce using rule 60 (statement -> assign .)
    IDENT           reduce using rule 60 (statement -> assign .)
    IF              reduce using rule 60 (statement -> assign .)
    PUT_LINE        reduce using rule 60 (statement -> assign .)
    LOOP            reduce using rule 60 (statement -> assign .)
    FOR             reduce using rule 60 (statement -> assign .)
    WHILE           reduce using rule 60 (statement -> assign .)
    RETURN          reduce using rule 60 (statement -> assign .)
    ELSE            reduce using rule 60 (statement -> assign .)
    ELSIF           reduce using rule 60 (statement -> assign .)


state 55

    (61) statement -> if .

    END             reduce using rule 61 (statement -> if .)
    IDENT           reduce using rule 61 (statement -> if .)
    IF              reduce using rule 61 (statement -> if .)
    PUT_LINE        reduce using rule 61 (statement -> if .)
    LOOP            reduce using rule 61 (statement -> if .)
    FOR             reduce using rule 61 (statement -> if .)
    WHILE           reduce using rule 61 (statement -> if .)
    RETURN          reduce using rule 61 (statement -> if .)
    ELSE            reduce using rule 61 (statement -> if .)
    ELSIF           reduce using rule 61 (statement -> if .)


state 56

    (62) statement -> loop .

    END             reduce using rule 62 (statement -> loop .)
    IDENT           reduce using rule 62 (statement -> loop .)
    IF              reduce using rule 62 (statement -> loop .)
    PUT_LINE        reduce using rule 62 (statement -> loop .)
    LOOP            reduce using rule 62 (statement -> loop .)
    FOR             reduce using rule 62 (statement -> loop .)
    WHILE           reduce using rule 62 (statement -> loop .)
    RETURN          reduce using rule 62 (statement -> loop .)
    ELSE            reduce using rule 62 (statement -> loop .)
    ELSIF           reduce using rule 62 (statement -> loop .)


state 57

    (63) statement -> put_line .

    END             reduce using rule 63 (statement -> put_line .)
    IDENT           reduce using rule 63 (statement -> put_line .)
    IF              reduce using rule 63 (statement -> put_line .)
    PUT_LINE        reduce using rule 63 (statement -> put_line .)
    LOOP            reduce using rule 63 (statement -> put_line .)
    FOR             reduce using rule 63 (statement -> put_line .)
    WHILE           reduce using rule 63 (statement -> put_line .)
    RETURN          reduce using rule 63 (statement -> put_line .)
    ELSE            reduce using rule 63 (statement -> put_line .)
    ELSIF           reduce using rule 63 (statement -> put_line .)


state 58

    (64) statement -> function_call . SEMICOLON

    SEMICOLON       shift and go to state 73


state 59

    (70) if -> IF . bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 78
    BOOL_VAL        shift and go to state 79
    IDENT           shift and go to state 80
    NUMBER          shift and go to state 82

    bool_expr                      shift and go to state 74
    bool_term                      shift and go to state 75
    bool                           shift and go to state 77
    rel_operand                    shift and go to state 81

state 60

    (76) loop -> loop_body .

    END             reduce using rule 76 (loop -> loop_body .)
    IDENT           reduce using rule 76 (loop -> loop_body .)
    IF              reduce using rule 76 (loop -> loop_body .)
    PUT_LINE        reduce using rule 76 (loop -> loop_body .)
    LOOP            reduce using rule 76 (loop -> loop_body .)
    FOR             reduce using rule 76 (loop -> loop_body .)
    WHILE           reduce using rule 76 (loop -> loop_body .)
    RETURN          reduce using rule 76 (loop -> loop_body .)
    ELSE            reduce using rule 76 (loop -> loop_body .)
    ELSIF           reduce using rule 76 (loop -> loop_body .)


state 61

    (77) loop -> for_range . loop_body
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON

    LOOP            shift and go to state 64

    loop_body                      shift and go to state 83

state 62

    (78) loop -> while . loop_body
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON

    LOOP            shift and go to state 64

    loop_body                      shift and go to state 84

state 63

    (82) put_line -> PUT_LINE . LEFT_PAR str_expr RIGHT_PAR SEMICOLON

    LEFT_PAR        shift and go to state 85


state 64

    (79) loop_body -> LOOP . statements END LOOP SEMICOLON
    (58) statements -> . statements statement
    (59) statements -> . statement
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    statements                     shift and go to state 86
    statement                      shift and go to state 53
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 65

    (80) for_range -> FOR . IDENT IN expr DUB_DOT expr

    IDENT           shift and go to state 87


state 66

    (81) while -> WHILE . bool_expr
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 78
    BOOL_VAL        shift and go to state 79
    IDENT           shift and go to state 80
    NUMBER          shift and go to state 82

    bool_expr                      shift and go to state 88
    bool_term                      shift and go to state 75
    bool                           shift and go to state 77
    rel_operand                    shift and go to state 81

state 67

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations . BEGIN ret_statements END IDENT SEMICOLON
    (23) declarations -> declarations . declaration
    (25) declaration -> . empty
    (26) declaration -> . function
    (27) declaration -> . procedure
    (28) declaration -> . IDENT COLON type ASSIGN value SEMICOLON
    (1) empty -> .
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (14) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PROC resolved as shift
    BEGIN           shift and go to state 89
    IDENT           shift and go to state 29
    FUNC            shift and go to state 8
    PROC            shift and go to state 7

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! IDENT           [ reduce using rule 1 (empty -> .) ]
  ! FUNC            [ reduce using rule 1 (empty -> .) ]
  ! PROC            [ reduce using rule 1 (empty -> .) ]

    declaration                    shift and go to state 45
    empty                          shift and go to state 32
    function                       shift and go to state 33
    procedure                      shift and go to state 34

state 68

    (28) declaration -> IDENT COLON type ASSIGN . value SEMICOLON
    (29) value -> . expr
    (30) value -> . bool_expr
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 96
    IDENT           shift and go to state 90
    NUMBER          shift and go to state 98
    BOOL_VAL        shift and go to state 79

    value                          shift and go to state 91
    expr                           shift and go to state 92
    bool_expr                      shift and go to state 93
    term                           shift and go to state 94
    bool_term                      shift and go to state 75
    factor                         shift and go to state 95
    bool                           shift and go to state 77
    function_call                  shift and go to state 97
    rel_operand                    shift and go to state 81

state 69

    (69) assign -> IDENT ASSIGN . value SEMICOLON
    (29) value -> . expr
    (30) value -> . bool_expr
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 96
    IDENT           shift and go to state 90
    NUMBER          shift and go to state 98
    BOOL_VAL        shift and go to state 79

    value                          shift and go to state 99
    expr                           shift and go to state 92
    bool_expr                      shift and go to state 93
    term                           shift and go to state 94
    bool_term                      shift and go to state 75
    factor                         shift and go to state 95
    bool                           shift and go to state 77
    function_call                  shift and go to state 97
    rel_operand                    shift and go to state 81

state 70

    (13) function_call -> IDENT LEFT_PAR . value RIGHT_PAR
    (29) value -> . expr
    (30) value -> . bool_expr
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 96
    IDENT           shift and go to state 90
    NUMBER          shift and go to state 98
    BOOL_VAL        shift and go to state 79

    value                          shift and go to state 100
    expr                           shift and go to state 92
    bool_expr                      shift and go to state 93
    term                           shift and go to state 94
    bool_term                      shift and go to state 75
    factor                         shift and go to state 95
    bool                           shift and go to state 77
    function_call                  shift and go to state 97
    rel_operand                    shift and go to state 81

state 71

    (14) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END . IDENT SEMICOLON

    IDENT           shift and go to state 101


state 72

    (58) statements -> statements statement .

    END             reduce using rule 58 (statements -> statements statement .)
    IDENT           reduce using rule 58 (statements -> statements statement .)
    IF              reduce using rule 58 (statements -> statements statement .)
    PUT_LINE        reduce using rule 58 (statements -> statements statement .)
    LOOP            reduce using rule 58 (statements -> statements statement .)
    FOR             reduce using rule 58 (statements -> statements statement .)
    WHILE           reduce using rule 58 (statements -> statements statement .)


state 73

    (64) statement -> function_call SEMICOLON .

    END             reduce using rule 64 (statement -> function_call SEMICOLON .)
    IDENT           reduce using rule 64 (statement -> function_call SEMICOLON .)
    IF              reduce using rule 64 (statement -> function_call SEMICOLON .)
    PUT_LINE        reduce using rule 64 (statement -> function_call SEMICOLON .)
    LOOP            reduce using rule 64 (statement -> function_call SEMICOLON .)
    FOR             reduce using rule 64 (statement -> function_call SEMICOLON .)
    WHILE           reduce using rule 64 (statement -> function_call SEMICOLON .)
    RETURN          reduce using rule 64 (statement -> function_call SEMICOLON .)
    ELSE            reduce using rule 64 (statement -> function_call SEMICOLON .)
    ELSIF           reduce using rule 64 (statement -> function_call SEMICOLON .)


state 74

    (70) if -> IF bool_expr . THEN ret_statements elsifs else END IF SEMICOLON

    THEN            shift and go to state 102


state 75

    (41) bool_expr -> bool_term . AND bool_term
    (42) bool_expr -> bool_term . OR bool_term
    (43) bool_expr -> bool_term .

    AND             shift and go to state 103
    OR              shift and go to state 104
    THEN            reduce using rule 43 (bool_expr -> bool_term .)
    LOOP            reduce using rule 43 (bool_expr -> bool_term .)
    SEMICOLON       reduce using rule 43 (bool_expr -> bool_term .)
    RIGHT_PAR       reduce using rule 43 (bool_expr -> bool_term .)


state 76

    (44) bool_term -> NOT . bool
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    LEFT_PAR        shift and go to state 78
    BOOL_VAL        shift and go to state 79
    IDENT           shift and go to state 80
    NUMBER          shift and go to state 82

    bool                           shift and go to state 105
    rel_operand                    shift and go to state 81

state 77

    (45) bool_term -> bool .

    AND             reduce using rule 45 (bool_term -> bool .)
    OR              reduce using rule 45 (bool_term -> bool .)
    THEN            reduce using rule 45 (bool_term -> bool .)
    LOOP            reduce using rule 45 (bool_term -> bool .)
    SEMICOLON       reduce using rule 45 (bool_term -> bool .)
    RIGHT_PAR       reduce using rule 45 (bool_term -> bool .)


state 78

    (46) bool -> LEFT_PAR . bool_expr RIGHT_PAR
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 78
    BOOL_VAL        shift and go to state 79
    IDENT           shift and go to state 80
    NUMBER          shift and go to state 82

    bool_expr                      shift and go to state 106
    bool_term                      shift and go to state 75
    bool                           shift and go to state 77
    rel_operand                    shift and go to state 81

state 79

    (47) bool -> BOOL_VAL .

    AND             reduce using rule 47 (bool -> BOOL_VAL .)
    OR              reduce using rule 47 (bool -> BOOL_VAL .)
    THEN            reduce using rule 47 (bool -> BOOL_VAL .)
    LOOP            reduce using rule 47 (bool -> BOOL_VAL .)
    SEMICOLON       reduce using rule 47 (bool -> BOOL_VAL .)
    RIGHT_PAR       reduce using rule 47 (bool -> BOOL_VAL .)


state 80

    (48) bool -> IDENT .
    (51) rel_operand -> IDENT .

    AND             reduce using rule 48 (bool -> IDENT .)
    OR              reduce using rule 48 (bool -> IDENT .)
    THEN            reduce using rule 48 (bool -> IDENT .)
    LOOP            reduce using rule 48 (bool -> IDENT .)
    SEMICOLON       reduce using rule 48 (bool -> IDENT .)
    RIGHT_PAR       reduce using rule 48 (bool -> IDENT .)
    EQUALS          reduce using rule 51 (rel_operand -> IDENT .)
    NOT_EQUALS      reduce using rule 51 (rel_operand -> IDENT .)
    GREATER         reduce using rule 51 (rel_operand -> IDENT .)
    LESS            reduce using rule 51 (rel_operand -> IDENT .)
    GTEQ            reduce using rule 51 (rel_operand -> IDENT .)
    LSEQ            reduce using rule 51 (rel_operand -> IDENT .)


state 81

    (49) bool -> rel_operand . rel_operator rel_operand
    (52) rel_operator -> . EQUALS
    (53) rel_operator -> . NOT_EQUALS
    (54) rel_operator -> . GREATER
    (55) rel_operator -> . LESS
    (56) rel_operator -> . GTEQ
    (57) rel_operator -> . LSEQ

    EQUALS          shift and go to state 108
    NOT_EQUALS      shift and go to state 109
    GREATER         shift and go to state 110
    LESS            shift and go to state 111
    GTEQ            shift and go to state 112
    LSEQ            shift and go to state 113

    rel_operator                   shift and go to state 107

state 82

    (50) rel_operand -> NUMBER .

    EQUALS          reduce using rule 50 (rel_operand -> NUMBER .)
    NOT_EQUALS      reduce using rule 50 (rel_operand -> NUMBER .)
    GREATER         reduce using rule 50 (rel_operand -> NUMBER .)
    LESS            reduce using rule 50 (rel_operand -> NUMBER .)
    GTEQ            reduce using rule 50 (rel_operand -> NUMBER .)
    LSEQ            reduce using rule 50 (rel_operand -> NUMBER .)
    AND             reduce using rule 50 (rel_operand -> NUMBER .)
    OR              reduce using rule 50 (rel_operand -> NUMBER .)
    THEN            reduce using rule 50 (rel_operand -> NUMBER .)
    LOOP            reduce using rule 50 (rel_operand -> NUMBER .)
    SEMICOLON       reduce using rule 50 (rel_operand -> NUMBER .)
    RIGHT_PAR       reduce using rule 50 (rel_operand -> NUMBER .)


state 83

    (77) loop -> for_range loop_body .

    END             reduce using rule 77 (loop -> for_range loop_body .)
    IDENT           reduce using rule 77 (loop -> for_range loop_body .)
    IF              reduce using rule 77 (loop -> for_range loop_body .)
    PUT_LINE        reduce using rule 77 (loop -> for_range loop_body .)
    LOOP            reduce using rule 77 (loop -> for_range loop_body .)
    FOR             reduce using rule 77 (loop -> for_range loop_body .)
    WHILE           reduce using rule 77 (loop -> for_range loop_body .)
    RETURN          reduce using rule 77 (loop -> for_range loop_body .)
    ELSE            reduce using rule 77 (loop -> for_range loop_body .)
    ELSIF           reduce using rule 77 (loop -> for_range loop_body .)


state 84

    (78) loop -> while loop_body .

    END             reduce using rule 78 (loop -> while loop_body .)
    IDENT           reduce using rule 78 (loop -> while loop_body .)
    IF              reduce using rule 78 (loop -> while loop_body .)
    PUT_LINE        reduce using rule 78 (loop -> while loop_body .)
    LOOP            reduce using rule 78 (loop -> while loop_body .)
    FOR             reduce using rule 78 (loop -> while loop_body .)
    WHILE           reduce using rule 78 (loop -> while loop_body .)
    RETURN          reduce using rule 78 (loop -> while loop_body .)
    ELSE            reduce using rule 78 (loop -> while loop_body .)
    ELSIF           reduce using rule 78 (loop -> while loop_body .)


state 85

    (82) put_line -> PUT_LINE LEFT_PAR . str_expr RIGHT_PAR SEMICOLON
    (83) str_expr -> . str_expr AMPERSAND str_term
    (84) str_expr -> . str_term
    (85) str_term -> . STRING
    (86) str_term -> . type APOSTROPHE IMAGE LEFT_PAR value RIGHT_PAR
    (20) type -> . TYPE_INT
    (21) type -> . TYPE_FLOAT
    (22) type -> . TYPE_BOOL

    STRING          shift and go to state 116
    TYPE_INT        shift and go to state 39
    TYPE_FLOAT      shift and go to state 40
    TYPE_BOOL       shift and go to state 41

    str_expr                       shift and go to state 114
    str_term                       shift and go to state 115
    type                           shift and go to state 117

state 86

    (79) loop_body -> LOOP statements . END LOOP SEMICOLON
    (58) statements -> statements . statement
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    END             shift and go to state 118
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    statement                      shift and go to state 72
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 87

    (80) for_range -> FOR IDENT . IN expr DUB_DOT expr

    IN              shift and go to state 119


state 88

    (81) while -> WHILE bool_expr .

    LOOP            reduce using rule 81 (while -> WHILE bool_expr .)


state 89

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN . ret_statements END IDENT SEMICOLON
    (65) ret_statements -> . ret_statements ret_statement
    (66) ret_statements -> . ret_statement
    (67) ret_statement -> . statement
    (68) ret_statement -> . RETURN value SEMICOLON
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    RETURN          shift and go to state 120
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    ret_statements                 shift and go to state 121
    ret_statement                  shift and go to state 122
    statement                      shift and go to state 123
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 90

    (39) factor -> IDENT .
    (48) bool -> IDENT .
    (13) function_call -> IDENT . LEFT_PAR value RIGHT_PAR
    (51) rel_operand -> IDENT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 39 (factor -> IDENT .)
  ! reduce/reduce conflict for RIGHT_PAR resolved using rule 39 (factor -> IDENT .)
    MUL             reduce using rule 39 (factor -> IDENT .)
    DIV             reduce using rule 39 (factor -> IDENT .)
    PLUS            reduce using rule 39 (factor -> IDENT .)
    MINUS           reduce using rule 39 (factor -> IDENT .)
    SEMICOLON       reduce using rule 39 (factor -> IDENT .)
    RIGHT_PAR       reduce using rule 39 (factor -> IDENT .)
    AND             reduce using rule 48 (bool -> IDENT .)
    OR              reduce using rule 48 (bool -> IDENT .)
    LEFT_PAR        shift and go to state 70
    EQUALS          reduce using rule 51 (rel_operand -> IDENT .)
    NOT_EQUALS      reduce using rule 51 (rel_operand -> IDENT .)
    GREATER         reduce using rule 51 (rel_operand -> IDENT .)
    LESS            reduce using rule 51 (rel_operand -> IDENT .)
    GTEQ            reduce using rule 51 (rel_operand -> IDENT .)
    LSEQ            reduce using rule 51 (rel_operand -> IDENT .)

  ! SEMICOLON       [ reduce using rule 48 (bool -> IDENT .) ]
  ! RIGHT_PAR       [ reduce using rule 48 (bool -> IDENT .) ]


state 91

    (28) declaration -> IDENT COLON type ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 124


state 92

    (29) value -> expr .
    (31) expr -> expr . PLUS term
    (32) expr -> expr . MINUS term

    SEMICOLON       reduce using rule 29 (value -> expr .)
    RIGHT_PAR       reduce using rule 29 (value -> expr .)
    PLUS            shift and go to state 125
    MINUS           shift and go to state 126


state 93

    (30) value -> bool_expr .

    SEMICOLON       reduce using rule 30 (value -> bool_expr .)
    RIGHT_PAR       reduce using rule 30 (value -> bool_expr .)


state 94

    (33) expr -> term .
    (34) term -> term . MUL factor
    (35) term -> term . DIV factor

    PLUS            reduce using rule 33 (expr -> term .)
    MINUS           reduce using rule 33 (expr -> term .)
    SEMICOLON       reduce using rule 33 (expr -> term .)
    RIGHT_PAR       reduce using rule 33 (expr -> term .)
    DUB_DOT         reduce using rule 33 (expr -> term .)
    LOOP            reduce using rule 33 (expr -> term .)
    MUL             shift and go to state 127
    DIV             shift and go to state 128


state 95

    (36) term -> factor .

    MUL             reduce using rule 36 (term -> factor .)
    DIV             reduce using rule 36 (term -> factor .)
    PLUS            reduce using rule 36 (term -> factor .)
    MINUS           reduce using rule 36 (term -> factor .)
    SEMICOLON       reduce using rule 36 (term -> factor .)
    RIGHT_PAR       reduce using rule 36 (term -> factor .)
    DUB_DOT         reduce using rule 36 (term -> factor .)
    LOOP            reduce using rule 36 (term -> factor .)


state 96

    (37) factor -> LEFT_PAR . expr RIGHT_PAR
    (46) bool -> LEFT_PAR . bool_expr RIGHT_PAR
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 96
    IDENT           shift and go to state 90
    NUMBER          shift and go to state 98
    BOOL_VAL        shift and go to state 79

    expr                           shift and go to state 129
    bool_expr                      shift and go to state 106
    term                           shift and go to state 94
    bool_term                      shift and go to state 75
    factor                         shift and go to state 95
    bool                           shift and go to state 77
    function_call                  shift and go to state 97
    rel_operand                    shift and go to state 81

state 97

    (38) factor -> function_call .

    MUL             reduce using rule 38 (factor -> function_call .)
    DIV             reduce using rule 38 (factor -> function_call .)
    PLUS            reduce using rule 38 (factor -> function_call .)
    MINUS           reduce using rule 38 (factor -> function_call .)
    SEMICOLON       reduce using rule 38 (factor -> function_call .)
    RIGHT_PAR       reduce using rule 38 (factor -> function_call .)
    DUB_DOT         reduce using rule 38 (factor -> function_call .)
    LOOP            reduce using rule 38 (factor -> function_call .)


state 98

    (40) factor -> NUMBER .
    (50) rel_operand -> NUMBER .

    MUL             reduce using rule 40 (factor -> NUMBER .)
    DIV             reduce using rule 40 (factor -> NUMBER .)
    PLUS            reduce using rule 40 (factor -> NUMBER .)
    MINUS           reduce using rule 40 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 40 (factor -> NUMBER .)
    RIGHT_PAR       reduce using rule 40 (factor -> NUMBER .)
    EQUALS          reduce using rule 50 (rel_operand -> NUMBER .)
    NOT_EQUALS      reduce using rule 50 (rel_operand -> NUMBER .)
    GREATER         reduce using rule 50 (rel_operand -> NUMBER .)
    LESS            reduce using rule 50 (rel_operand -> NUMBER .)
    GTEQ            reduce using rule 50 (rel_operand -> NUMBER .)
    LSEQ            reduce using rule 50 (rel_operand -> NUMBER .)


state 99

    (69) assign -> IDENT ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 130


state 100

    (13) function_call -> IDENT LEFT_PAR value . RIGHT_PAR

    RIGHT_PAR       shift and go to state 131


state 101

    (14) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT . SEMICOLON

    SEMICOLON       shift and go to state 132


state 102

    (70) if -> IF bool_expr THEN . ret_statements elsifs else END IF SEMICOLON
    (65) ret_statements -> . ret_statements ret_statement
    (66) ret_statements -> . ret_statement
    (67) ret_statement -> . statement
    (68) ret_statement -> . RETURN value SEMICOLON
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    RETURN          shift and go to state 120
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    ret_statements                 shift and go to state 133
    ret_statement                  shift and go to state 122
    statement                      shift and go to state 123
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 103

    (41) bool_expr -> bool_term AND . bool_term
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 78
    BOOL_VAL        shift and go to state 79
    IDENT           shift and go to state 80
    NUMBER          shift and go to state 82

    bool_term                      shift and go to state 134
    bool                           shift and go to state 77
    rel_operand                    shift and go to state 81

state 104

    (42) bool_expr -> bool_term OR . bool_term
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 78
    BOOL_VAL        shift and go to state 79
    IDENT           shift and go to state 80
    NUMBER          shift and go to state 82

    bool_term                      shift and go to state 135
    bool                           shift and go to state 77
    rel_operand                    shift and go to state 81

state 105

    (44) bool_term -> NOT bool .

    AND             reduce using rule 44 (bool_term -> NOT bool .)
    OR              reduce using rule 44 (bool_term -> NOT bool .)
    THEN            reduce using rule 44 (bool_term -> NOT bool .)
    LOOP            reduce using rule 44 (bool_term -> NOT bool .)
    SEMICOLON       reduce using rule 44 (bool_term -> NOT bool .)
    RIGHT_PAR       reduce using rule 44 (bool_term -> NOT bool .)


state 106

    (46) bool -> LEFT_PAR bool_expr . RIGHT_PAR

    RIGHT_PAR       shift and go to state 136


state 107

    (49) bool -> rel_operand rel_operator . rel_operand
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NUMBER          shift and go to state 82
    IDENT           shift and go to state 138

    rel_operand                    shift and go to state 137

state 108

    (52) rel_operator -> EQUALS .

    NUMBER          reduce using rule 52 (rel_operator -> EQUALS .)
    IDENT           reduce using rule 52 (rel_operator -> EQUALS .)


state 109

    (53) rel_operator -> NOT_EQUALS .

    NUMBER          reduce using rule 53 (rel_operator -> NOT_EQUALS .)
    IDENT           reduce using rule 53 (rel_operator -> NOT_EQUALS .)


state 110

    (54) rel_operator -> GREATER .

    NUMBER          reduce using rule 54 (rel_operator -> GREATER .)
    IDENT           reduce using rule 54 (rel_operator -> GREATER .)


state 111

    (55) rel_operator -> LESS .

    NUMBER          reduce using rule 55 (rel_operator -> LESS .)
    IDENT           reduce using rule 55 (rel_operator -> LESS .)


state 112

    (56) rel_operator -> GTEQ .

    NUMBER          reduce using rule 56 (rel_operator -> GTEQ .)
    IDENT           reduce using rule 56 (rel_operator -> GTEQ .)


state 113

    (57) rel_operator -> LSEQ .

    NUMBER          reduce using rule 57 (rel_operator -> LSEQ .)
    IDENT           reduce using rule 57 (rel_operator -> LSEQ .)


state 114

    (82) put_line -> PUT_LINE LEFT_PAR str_expr . RIGHT_PAR SEMICOLON
    (83) str_expr -> str_expr . AMPERSAND str_term

    RIGHT_PAR       shift and go to state 139
    AMPERSAND       shift and go to state 140


state 115

    (84) str_expr -> str_term .

    RIGHT_PAR       reduce using rule 84 (str_expr -> str_term .)
    AMPERSAND       reduce using rule 84 (str_expr -> str_term .)


state 116

    (85) str_term -> STRING .

    RIGHT_PAR       reduce using rule 85 (str_term -> STRING .)
    AMPERSAND       reduce using rule 85 (str_term -> STRING .)


state 117

    (86) str_term -> type . APOSTROPHE IMAGE LEFT_PAR value RIGHT_PAR

    APOSTROPHE      shift and go to state 141


state 118

    (79) loop_body -> LOOP statements END . LOOP SEMICOLON

    LOOP            shift and go to state 142


state 119

    (80) for_range -> FOR IDENT IN . expr DUB_DOT expr
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR

    LEFT_PAR        shift and go to state 145
    IDENT           shift and go to state 143
    NUMBER          shift and go to state 146

    expr                           shift and go to state 144
    term                           shift and go to state 94
    factor                         shift and go to state 95
    function_call                  shift and go to state 97

state 120

    (68) ret_statement -> RETURN . value SEMICOLON
    (29) value -> . expr
    (30) value -> . bool_expr
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 96
    IDENT           shift and go to state 90
    NUMBER          shift and go to state 98
    BOOL_VAL        shift and go to state 79

    value                          shift and go to state 147
    expr                           shift and go to state 92
    bool_expr                      shift and go to state 93
    term                           shift and go to state 94
    bool_term                      shift and go to state 75
    factor                         shift and go to state 95
    bool                           shift and go to state 77
    function_call                  shift and go to state 97
    rel_operand                    shift and go to state 81

state 121

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements . END IDENT SEMICOLON
    (65) ret_statements -> ret_statements . ret_statement
    (67) ret_statement -> . statement
    (68) ret_statement -> . RETURN value SEMICOLON
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    END             shift and go to state 148
    RETURN          shift and go to state 120
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    ret_statement                  shift and go to state 149
    statement                      shift and go to state 123
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 122

    (66) ret_statements -> ret_statement .

    END             reduce using rule 66 (ret_statements -> ret_statement .)
    RETURN          reduce using rule 66 (ret_statements -> ret_statement .)
    IDENT           reduce using rule 66 (ret_statements -> ret_statement .)
    IF              reduce using rule 66 (ret_statements -> ret_statement .)
    PUT_LINE        reduce using rule 66 (ret_statements -> ret_statement .)
    LOOP            reduce using rule 66 (ret_statements -> ret_statement .)
    FOR             reduce using rule 66 (ret_statements -> ret_statement .)
    WHILE           reduce using rule 66 (ret_statements -> ret_statement .)
    ELSE            reduce using rule 66 (ret_statements -> ret_statement .)
    ELSIF           reduce using rule 66 (ret_statements -> ret_statement .)


state 123

    (67) ret_statement -> statement .

    END             reduce using rule 67 (ret_statement -> statement .)
    RETURN          reduce using rule 67 (ret_statement -> statement .)
    IDENT           reduce using rule 67 (ret_statement -> statement .)
    IF              reduce using rule 67 (ret_statement -> statement .)
    PUT_LINE        reduce using rule 67 (ret_statement -> statement .)
    LOOP            reduce using rule 67 (ret_statement -> statement .)
    FOR             reduce using rule 67 (ret_statement -> statement .)
    WHILE           reduce using rule 67 (ret_statement -> statement .)
    ELSE            reduce using rule 67 (ret_statement -> statement .)
    ELSIF           reduce using rule 67 (ret_statement -> statement .)


state 124

    (28) declaration -> IDENT COLON type ASSIGN value SEMICOLON .

    BEGIN           reduce using rule 28 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)
    IDENT           reduce using rule 28 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)
    FUNC            reduce using rule 28 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)
    PROC            reduce using rule 28 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)


state 125

    (31) expr -> expr PLUS . term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR

    LEFT_PAR        shift and go to state 145
    IDENT           shift and go to state 143
    NUMBER          shift and go to state 146

    term                           shift and go to state 150
    factor                         shift and go to state 95
    function_call                  shift and go to state 97

state 126

    (32) expr -> expr MINUS . term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR

    LEFT_PAR        shift and go to state 145
    IDENT           shift and go to state 143
    NUMBER          shift and go to state 146

    term                           shift and go to state 151
    factor                         shift and go to state 95
    function_call                  shift and go to state 97

state 127

    (34) term -> term MUL . factor
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR

    LEFT_PAR        shift and go to state 145
    IDENT           shift and go to state 143
    NUMBER          shift and go to state 146

    factor                         shift and go to state 152
    function_call                  shift and go to state 97

state 128

    (35) term -> term DIV . factor
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR

    LEFT_PAR        shift and go to state 145
    IDENT           shift and go to state 143
    NUMBER          shift and go to state 146

    factor                         shift and go to state 153
    function_call                  shift and go to state 97

state 129

    (37) factor -> LEFT_PAR expr . RIGHT_PAR
    (31) expr -> expr . PLUS term
    (32) expr -> expr . MINUS term

    RIGHT_PAR       shift and go to state 154
    PLUS            shift and go to state 125
    MINUS           shift and go to state 126


state 130

    (69) assign -> IDENT ASSIGN value SEMICOLON .

    END             reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    IDENT           reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    IF              reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    PUT_LINE        reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    LOOP            reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    FOR             reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    WHILE           reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    RETURN          reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    ELSE            reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)
    ELSIF           reduce using rule 69 (assign -> IDENT ASSIGN value SEMICOLON .)


state 131

    (13) function_call -> IDENT LEFT_PAR value RIGHT_PAR .

    SEMICOLON       reduce using rule 13 (function_call -> IDENT LEFT_PAR value RIGHT_PAR .)
    MUL             reduce using rule 13 (function_call -> IDENT LEFT_PAR value RIGHT_PAR .)
    DIV             reduce using rule 13 (function_call -> IDENT LEFT_PAR value RIGHT_PAR .)
    PLUS            reduce using rule 13 (function_call -> IDENT LEFT_PAR value RIGHT_PAR .)
    MINUS           reduce using rule 13 (function_call -> IDENT LEFT_PAR value RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 13 (function_call -> IDENT LEFT_PAR value RIGHT_PAR .)
    DUB_DOT         reduce using rule 13 (function_call -> IDENT LEFT_PAR value RIGHT_PAR .)
    LOOP            reduce using rule 13 (function_call -> IDENT LEFT_PAR value RIGHT_PAR .)


state 132

    (14) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .

    $end            reduce using rule 14 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)
    BEGIN           reduce using rule 14 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)
    IDENT           reduce using rule 14 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)
    FUNC            reduce using rule 14 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)
    PROC            reduce using rule 14 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)


state 133

    (70) if -> IF bool_expr THEN ret_statements . elsifs else END IF SEMICOLON
    (65) ret_statements -> ret_statements . ret_statement
    (71) elsifs -> . elsifs elsif
    (72) elsifs -> . empty
    (67) ret_statement -> . statement
    (68) ret_statement -> . RETURN value SEMICOLON
    (1) empty -> .
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    RETURN          shift and go to state 120
    ELSE            reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    elsifs                         shift and go to state 155
    ret_statement                  shift and go to state 149
    empty                          shift and go to state 156
    statement                      shift and go to state 123
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 134

    (41) bool_expr -> bool_term AND bool_term .

    THEN            reduce using rule 41 (bool_expr -> bool_term AND bool_term .)
    LOOP            reduce using rule 41 (bool_expr -> bool_term AND bool_term .)
    SEMICOLON       reduce using rule 41 (bool_expr -> bool_term AND bool_term .)
    RIGHT_PAR       reduce using rule 41 (bool_expr -> bool_term AND bool_term .)


state 135

    (42) bool_expr -> bool_term OR bool_term .

    THEN            reduce using rule 42 (bool_expr -> bool_term OR bool_term .)
    LOOP            reduce using rule 42 (bool_expr -> bool_term OR bool_term .)
    SEMICOLON       reduce using rule 42 (bool_expr -> bool_term OR bool_term .)
    RIGHT_PAR       reduce using rule 42 (bool_expr -> bool_term OR bool_term .)


state 136

    (46) bool -> LEFT_PAR bool_expr RIGHT_PAR .

    AND             reduce using rule 46 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    OR              reduce using rule 46 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    THEN            reduce using rule 46 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    LOOP            reduce using rule 46 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 46 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 46 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)


state 137

    (49) bool -> rel_operand rel_operator rel_operand .

    AND             reduce using rule 49 (bool -> rel_operand rel_operator rel_operand .)
    OR              reduce using rule 49 (bool -> rel_operand rel_operator rel_operand .)
    THEN            reduce using rule 49 (bool -> rel_operand rel_operator rel_operand .)
    LOOP            reduce using rule 49 (bool -> rel_operand rel_operator rel_operand .)
    SEMICOLON       reduce using rule 49 (bool -> rel_operand rel_operator rel_operand .)
    RIGHT_PAR       reduce using rule 49 (bool -> rel_operand rel_operator rel_operand .)


state 138

    (51) rel_operand -> IDENT .

    AND             reduce using rule 51 (rel_operand -> IDENT .)
    OR              reduce using rule 51 (rel_operand -> IDENT .)
    THEN            reduce using rule 51 (rel_operand -> IDENT .)
    LOOP            reduce using rule 51 (rel_operand -> IDENT .)
    SEMICOLON       reduce using rule 51 (rel_operand -> IDENT .)
    RIGHT_PAR       reduce using rule 51 (rel_operand -> IDENT .)


state 139

    (82) put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR . SEMICOLON

    SEMICOLON       shift and go to state 157


state 140

    (83) str_expr -> str_expr AMPERSAND . str_term
    (85) str_term -> . STRING
    (86) str_term -> . type APOSTROPHE IMAGE LEFT_PAR value RIGHT_PAR
    (20) type -> . TYPE_INT
    (21) type -> . TYPE_FLOAT
    (22) type -> . TYPE_BOOL

    STRING          shift and go to state 116
    TYPE_INT        shift and go to state 39
    TYPE_FLOAT      shift and go to state 40
    TYPE_BOOL       shift and go to state 41

    str_term                       shift and go to state 158
    type                           shift and go to state 117

state 141

    (86) str_term -> type APOSTROPHE . IMAGE LEFT_PAR value RIGHT_PAR

    IMAGE           shift and go to state 159


state 142

    (79) loop_body -> LOOP statements END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 160


state 143

    (39) factor -> IDENT .
    (13) function_call -> IDENT . LEFT_PAR value RIGHT_PAR

    MUL             reduce using rule 39 (factor -> IDENT .)
    DIV             reduce using rule 39 (factor -> IDENT .)
    DUB_DOT         reduce using rule 39 (factor -> IDENT .)
    PLUS            reduce using rule 39 (factor -> IDENT .)
    MINUS           reduce using rule 39 (factor -> IDENT .)
    SEMICOLON       reduce using rule 39 (factor -> IDENT .)
    RIGHT_PAR       reduce using rule 39 (factor -> IDENT .)
    LOOP            reduce using rule 39 (factor -> IDENT .)
    LEFT_PAR        shift and go to state 70


state 144

    (80) for_range -> FOR IDENT IN expr . DUB_DOT expr
    (31) expr -> expr . PLUS term
    (32) expr -> expr . MINUS term

    DUB_DOT         shift and go to state 161
    PLUS            shift and go to state 125
    MINUS           shift and go to state 126


state 145

    (37) factor -> LEFT_PAR . expr RIGHT_PAR
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR

    LEFT_PAR        shift and go to state 145
    IDENT           shift and go to state 143
    NUMBER          shift and go to state 146

    expr                           shift and go to state 129
    term                           shift and go to state 94
    factor                         shift and go to state 95
    function_call                  shift and go to state 97

state 146

    (40) factor -> NUMBER .

    MUL             reduce using rule 40 (factor -> NUMBER .)
    DIV             reduce using rule 40 (factor -> NUMBER .)
    DUB_DOT         reduce using rule 40 (factor -> NUMBER .)
    PLUS            reduce using rule 40 (factor -> NUMBER .)
    MINUS           reduce using rule 40 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 40 (factor -> NUMBER .)
    RIGHT_PAR       reduce using rule 40 (factor -> NUMBER .)
    LOOP            reduce using rule 40 (factor -> NUMBER .)


state 147

    (68) ret_statement -> RETURN value . SEMICOLON

    SEMICOLON       shift and go to state 162


state 148

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END . IDENT SEMICOLON

    IDENT           shift and go to state 163


state 149

    (65) ret_statements -> ret_statements ret_statement .

    END             reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    RETURN          reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    IDENT           reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    IF              reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    PUT_LINE        reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    LOOP            reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    FOR             reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    WHILE           reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    ELSE            reduce using rule 65 (ret_statements -> ret_statements ret_statement .)
    ELSIF           reduce using rule 65 (ret_statements -> ret_statements ret_statement .)


state 150

    (31) expr -> expr PLUS term .
    (34) term -> term . MUL factor
    (35) term -> term . DIV factor

    PLUS            reduce using rule 31 (expr -> expr PLUS term .)
    MINUS           reduce using rule 31 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 31 (expr -> expr PLUS term .)
    RIGHT_PAR       reduce using rule 31 (expr -> expr PLUS term .)
    DUB_DOT         reduce using rule 31 (expr -> expr PLUS term .)
    LOOP            reduce using rule 31 (expr -> expr PLUS term .)
    MUL             shift and go to state 127
    DIV             shift and go to state 128


state 151

    (32) expr -> expr MINUS term .
    (34) term -> term . MUL factor
    (35) term -> term . DIV factor

    PLUS            reduce using rule 32 (expr -> expr MINUS term .)
    MINUS           reduce using rule 32 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 32 (expr -> expr MINUS term .)
    RIGHT_PAR       reduce using rule 32 (expr -> expr MINUS term .)
    DUB_DOT         reduce using rule 32 (expr -> expr MINUS term .)
    LOOP            reduce using rule 32 (expr -> expr MINUS term .)
    MUL             shift and go to state 127
    DIV             shift and go to state 128


state 152

    (34) term -> term MUL factor .

    MUL             reduce using rule 34 (term -> term MUL factor .)
    DIV             reduce using rule 34 (term -> term MUL factor .)
    PLUS            reduce using rule 34 (term -> term MUL factor .)
    MINUS           reduce using rule 34 (term -> term MUL factor .)
    SEMICOLON       reduce using rule 34 (term -> term MUL factor .)
    RIGHT_PAR       reduce using rule 34 (term -> term MUL factor .)
    DUB_DOT         reduce using rule 34 (term -> term MUL factor .)
    LOOP            reduce using rule 34 (term -> term MUL factor .)


state 153

    (35) term -> term DIV factor .

    MUL             reduce using rule 35 (term -> term DIV factor .)
    DIV             reduce using rule 35 (term -> term DIV factor .)
    PLUS            reduce using rule 35 (term -> term DIV factor .)
    MINUS           reduce using rule 35 (term -> term DIV factor .)
    SEMICOLON       reduce using rule 35 (term -> term DIV factor .)
    RIGHT_PAR       reduce using rule 35 (term -> term DIV factor .)
    DUB_DOT         reduce using rule 35 (term -> term DIV factor .)
    LOOP            reduce using rule 35 (term -> term DIV factor .)


state 154

    (37) factor -> LEFT_PAR expr RIGHT_PAR .

    MUL             reduce using rule 37 (factor -> LEFT_PAR expr RIGHT_PAR .)
    DIV             reduce using rule 37 (factor -> LEFT_PAR expr RIGHT_PAR .)
    PLUS            reduce using rule 37 (factor -> LEFT_PAR expr RIGHT_PAR .)
    MINUS           reduce using rule 37 (factor -> LEFT_PAR expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 37 (factor -> LEFT_PAR expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 37 (factor -> LEFT_PAR expr RIGHT_PAR .)
    DUB_DOT         reduce using rule 37 (factor -> LEFT_PAR expr RIGHT_PAR .)
    LOOP            reduce using rule 37 (factor -> LEFT_PAR expr RIGHT_PAR .)


state 155

    (70) if -> IF bool_expr THEN ret_statements elsifs . else END IF SEMICOLON
    (71) elsifs -> elsifs . elsif
    (74) else -> . ELSE ret_statements
    (75) else -> . empty
    (73) elsif -> . ELSIF bool_expr THEN ret_statements
    (1) empty -> .

    ELSE            shift and go to state 166
    ELSIF           shift and go to state 168
    END             reduce using rule 1 (empty -> .)

    else                           shift and go to state 164
    elsif                          shift and go to state 165
    empty                          shift and go to state 167

state 156

    (72) elsifs -> empty .

    ELSE            reduce using rule 72 (elsifs -> empty .)
    ELSIF           reduce using rule 72 (elsifs -> empty .)
    END             reduce using rule 72 (elsifs -> empty .)


state 157

    (82) put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .

    END             reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    IDENT           reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    IF              reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    PUT_LINE        reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    LOOP            reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    FOR             reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    WHILE           reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    RETURN          reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    ELSE            reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)
    ELSIF           reduce using rule 82 (put_line -> PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON .)


state 158

    (83) str_expr -> str_expr AMPERSAND str_term .

    RIGHT_PAR       reduce using rule 83 (str_expr -> str_expr AMPERSAND str_term .)
    AMPERSAND       reduce using rule 83 (str_expr -> str_expr AMPERSAND str_term .)


state 159

    (86) str_term -> type APOSTROPHE IMAGE . LEFT_PAR value RIGHT_PAR

    LEFT_PAR        shift and go to state 169


state 160

    (79) loop_body -> LOOP statements END LOOP SEMICOLON .

    END             reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    IDENT           reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    IF              reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    PUT_LINE        reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    LOOP            reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    FOR             reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    WHILE           reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    RETURN          reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    ELSE            reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    ELSIF           reduce using rule 79 (loop_body -> LOOP statements END LOOP SEMICOLON .)


state 161

    (80) for_range -> FOR IDENT IN expr DUB_DOT . expr
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR

    LEFT_PAR        shift and go to state 145
    IDENT           shift and go to state 143
    NUMBER          shift and go to state 146

    expr                           shift and go to state 170
    term                           shift and go to state 94
    factor                         shift and go to state 95
    function_call                  shift and go to state 97

state 162

    (68) ret_statement -> RETURN value SEMICOLON .

    END             reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    RETURN          reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    IDENT           reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    IF              reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    PUT_LINE        reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    LOOP            reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    FOR             reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    WHILE           reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    ELSE            reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)
    ELSIF           reduce using rule 68 (ret_statement -> RETURN value SEMICOLON .)


state 163

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT . SEMICOLON

    SEMICOLON       shift and go to state 171


state 164

    (70) if -> IF bool_expr THEN ret_statements elsifs else . END IF SEMICOLON

    END             shift and go to state 172


state 165

    (71) elsifs -> elsifs elsif .

    ELSE            reduce using rule 71 (elsifs -> elsifs elsif .)
    ELSIF           reduce using rule 71 (elsifs -> elsifs elsif .)
    END             reduce using rule 71 (elsifs -> elsifs elsif .)


state 166

    (74) else -> ELSE . ret_statements
    (65) ret_statements -> . ret_statements ret_statement
    (66) ret_statements -> . ret_statement
    (67) ret_statement -> . statement
    (68) ret_statement -> . RETURN value SEMICOLON
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    RETURN          shift and go to state 120
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    ret_statements                 shift and go to state 173
    ret_statement                  shift and go to state 122
    statement                      shift and go to state 123
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 167

    (75) else -> empty .

    END             reduce using rule 75 (else -> empty .)


state 168

    (73) elsif -> ELSIF . bool_expr THEN ret_statements
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 78
    BOOL_VAL        shift and go to state 79
    IDENT           shift and go to state 80
    NUMBER          shift and go to state 82

    bool_expr                      shift and go to state 174
    bool_term                      shift and go to state 75
    bool                           shift and go to state 77
    rel_operand                    shift and go to state 81

state 169

    (86) str_term -> type APOSTROPHE IMAGE LEFT_PAR . value RIGHT_PAR
    (29) value -> . expr
    (30) value -> . bool_expr
    (31) expr -> . expr PLUS term
    (32) expr -> . expr MINUS term
    (33) expr -> . term
    (41) bool_expr -> . bool_term AND bool_term
    (42) bool_expr -> . bool_term OR bool_term
    (43) bool_expr -> . bool_term
    (34) term -> . term MUL factor
    (35) term -> . term DIV factor
    (36) term -> . factor
    (44) bool_term -> . NOT bool
    (45) bool_term -> . bool
    (37) factor -> . LEFT_PAR expr RIGHT_PAR
    (38) factor -> . function_call
    (39) factor -> . IDENT
    (40) factor -> . NUMBER
    (46) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (47) bool -> . BOOL_VAL
    (48) bool -> . IDENT
    (49) bool -> . rel_operand rel_operator rel_operand
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (50) rel_operand -> . NUMBER
    (51) rel_operand -> . IDENT

    NOT             shift and go to state 76
    LEFT_PAR        shift and go to state 96
    IDENT           shift and go to state 90
    NUMBER          shift and go to state 98
    BOOL_VAL        shift and go to state 79

    value                          shift and go to state 175
    expr                           shift and go to state 92
    bool_expr                      shift and go to state 93
    term                           shift and go to state 94
    bool_term                      shift and go to state 75
    factor                         shift and go to state 95
    bool                           shift and go to state 77
    function_call                  shift and go to state 97
    rel_operand                    shift and go to state 81

state 170

    (80) for_range -> FOR IDENT IN expr DUB_DOT expr .
    (31) expr -> expr . PLUS term
    (32) expr -> expr . MINUS term

    LOOP            reduce using rule 80 (for_range -> FOR IDENT IN expr DUB_DOT expr .)
    PLUS            shift and go to state 125
    MINUS           shift and go to state 126


state 171

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .

    $end            reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)
    BEGIN           reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)
    IDENT           reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)
    FUNC            reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)
    PROC            reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)


state 172

    (70) if -> IF bool_expr THEN ret_statements elsifs else END . IF SEMICOLON

    IF              shift and go to state 176


state 173

    (74) else -> ELSE ret_statements .
    (65) ret_statements -> ret_statements . ret_statement
    (67) ret_statement -> . statement
    (68) ret_statement -> . RETURN value SEMICOLON
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    END             reduce using rule 74 (else -> ELSE ret_statements .)
    RETURN          shift and go to state 120
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    ret_statement                  shift and go to state 149
    statement                      shift and go to state 123
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 174

    (73) elsif -> ELSIF bool_expr . THEN ret_statements

    THEN            shift and go to state 177


state 175

    (86) str_term -> type APOSTROPHE IMAGE LEFT_PAR value . RIGHT_PAR

    RIGHT_PAR       shift and go to state 178


state 176

    (70) if -> IF bool_expr THEN ret_statements elsifs else END IF . SEMICOLON

    SEMICOLON       shift and go to state 179


state 177

    (73) elsif -> ELSIF bool_expr THEN . ret_statements
    (65) ret_statements -> . ret_statements ret_statement
    (66) ret_statements -> . ret_statement
    (67) ret_statement -> . statement
    (68) ret_statement -> . RETURN value SEMICOLON
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    RETURN          shift and go to state 120
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    ret_statements                 shift and go to state 180
    ret_statement                  shift and go to state 122
    statement                      shift and go to state 123
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62

state 178

    (86) str_term -> type APOSTROPHE IMAGE LEFT_PAR value RIGHT_PAR .

    RIGHT_PAR       reduce using rule 86 (str_term -> type APOSTROPHE IMAGE LEFT_PAR value RIGHT_PAR .)
    AMPERSAND       reduce using rule 86 (str_term -> type APOSTROPHE IMAGE LEFT_PAR value RIGHT_PAR .)


state 179

    (70) if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .

    END             reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    IDENT           reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    IF              reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    PUT_LINE        reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    LOOP            reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    FOR             reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    WHILE           reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    RETURN          reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    ELSE            reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    ELSIF           reduce using rule 70 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)


state 180

    (73) elsif -> ELSIF bool_expr THEN ret_statements .
    (65) ret_statements -> ret_statements . ret_statement
    (67) ret_statement -> . statement
    (68) ret_statement -> . RETURN value SEMICOLON
    (60) statement -> . assign
    (61) statement -> . if
    (62) statement -> . loop
    (63) statement -> . put_line
    (64) statement -> . function_call SEMICOLON
    (69) assign -> . IDENT ASSIGN value SEMICOLON
    (70) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (76) loop -> . loop_body
    (77) loop -> . for_range loop_body
    (78) loop -> . while loop_body
    (82) put_line -> . PUT_LINE LEFT_PAR str_expr RIGHT_PAR SEMICOLON
    (13) function_call -> . IDENT LEFT_PAR value RIGHT_PAR
    (79) loop_body -> . LOOP statements END LOOP SEMICOLON
    (80) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (81) while -> . WHILE bool_expr

    ELSE            reduce using rule 73 (elsif -> ELSIF bool_expr THEN ret_statements .)
    ELSIF           reduce using rule 73 (elsif -> ELSIF bool_expr THEN ret_statements .)
    END             reduce using rule 73 (elsif -> ELSIF bool_expr THEN ret_statements .)
    RETURN          shift and go to state 120
    IDENT           shift and go to state 51
    IF              shift and go to state 59
    PUT_LINE        shift and go to state 63
    LOOP            shift and go to state 64
    FOR             shift and go to state 65
    WHILE           shift and go to state 66

    ret_statement                  shift and go to state 149
    statement                      shift and go to state 123
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    put_line                       shift and go to state 57
    function_call                  shift and go to state 58
    loop_body                      shift and go to state 60
    for_range                      shift and go to state 61
    while                          shift and go to state 62
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENT in state 22 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 22 resolved as shift
WARNING: shift/reduce conflict for PROC in state 22 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 30 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 30 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 30 resolved as shift
WARNING: shift/reduce conflict for PROC in state 30 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 48 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 48 resolved as shift
WARNING: shift/reduce conflict for PROC in state 48 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 67 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 67 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 67 resolved as shift
WARNING: shift/reduce conflict for PROC in state 67 resolved as shift
WARNING: reduce/reduce conflict in state 90 resolved using rule (factor -> IDENT)
WARNING: rejected rule (bool -> IDENT) in state 90
