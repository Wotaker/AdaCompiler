Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABS
    AMPERSAND
    APOSTROPHE
    ARRAY
    BOOL
    COMMENT
    DECLARE
    LEFT_CUR_PAR
    LEFT_SQ_PAR
    MOD
    NULL
    OF
    POW
    QUOTE
    REVERSE
    RIGHT_CUR_PAR
    RIGHT_SQ_PAR
    XOR

Grammar

Rule 0     S' -> prog
Rule 1     empty -> <empty>
Rule 2     prog -> subprogram
Rule 3     prog -> headers subprogram
Rule 4     headers -> headers header
Rule 5     headers -> header
Rule 6     header -> WITH pkg SEMICOLON
Rule 7     header -> WITH pkg SEMICOLON USE pkg SEMICOLON
Rule 8     pkg -> pkg DOT IDENT
Rule 9     pkg -> IDENT
Rule 10    subprogram -> procedure
Rule 11    subprogram -> function
Rule 12    function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
Rule 13    procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
Rule 14    args_opt -> LEFT_PAR args RIGHT_PAR
Rule 15    args_opt -> empty
Rule 16    args -> args COMMA arg
Rule 17    args -> arg
Rule 18    arg -> IDENT COLON type
Rule 19    type -> TYPE_INT
Rule 20    type -> TYPE_FLOAT
Rule 21    type -> TYPE_BOOL
Rule 22    declarations -> declarations declaration
Rule 23    declarations -> declaration
Rule 24    declaration -> empty
Rule 25    declaration -> function
Rule 26    declaration -> procedure
Rule 27    declaration -> IDENT COLON type ASSIGN value SEMICOLON
Rule 28    value -> expr
Rule 29    value -> bool_expr
Rule 30    expr -> expr PLUS term
Rule 31    expr -> expr MINUS term
Rule 32    expr -> term
Rule 33    term -> term MUL factor
Rule 34    term -> term DIV factor
Rule 35    term -> factor
Rule 36    factor -> LEFT_PAR expr RIGHT_PAR
Rule 37    factor -> IDENT
Rule 38    factor -> NUMBER
Rule 39    bool_expr -> bool_term AND bool_term
Rule 40    bool_expr -> bool_term OR bool_term
Rule 41    bool_expr -> bool_term
Rule 42    bool_term -> NOT bool
Rule 43    bool_term -> bool
Rule 44    bool -> LEFT_PAR bool_expr RIGHT_PAR
Rule 45    bool -> BOOL_VAL
Rule 46    bool -> IDENT
Rule 47    bool -> rel_operand rel_operator rel_operand
Rule 48    rel_operand -> NUMBER
Rule 49    rel_operand -> IDENT
Rule 50    rel_operator -> EQUALS
Rule 51    rel_operator -> NOT_EQUALS
Rule 52    rel_operator -> GREATER
Rule 53    rel_operator -> LESS
Rule 54    rel_operator -> GTEQ
Rule 55    rel_operator -> LSEQ
Rule 56    statements -> statements statement
Rule 57    statements -> statement
Rule 58    statement -> assign
Rule 59    statement -> if
Rule 60    statement -> loop
Rule 61    ret_statements -> ret_statements ret_statement
Rule 62    ret_statements -> ret_statement
Rule 63    ret_statement -> statement
Rule 64    ret_statement -> RETURN value SEMICOLON
Rule 65    assign -> IDENT ASSIGN value SEMICOLON
Rule 66    if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
Rule 67    elsifs -> elsifs elsif
Rule 68    elsifs -> empty
Rule 69    elsif -> ELSIF bool_expr THEN ret_statements
Rule 70    else -> ELSE ret_statements
Rule 71    else -> empty
Rule 72    loop -> loop_body
Rule 73    loop -> for_range loop_body
Rule 74    loop -> while loop_body
Rule 75    loop_body -> LOOP statements END LOOP SEMICOLON
Rule 76    for_range -> FOR IDENT IN expr DUB_DOT expr
Rule 77    while -> WHILE bool_expr

Terminals, with rules where they appear

ABS                  : 
AMPERSAND            : 
AND                  : 39
APOSTROPHE           : 
ARRAY                : 
ASSIGN               : 27 65
BEGIN                : 12 13
BOOL                 : 
BOOL_VAL             : 45
COLON                : 18 27
COMMA                : 16
COMMENT              : 
DECLARE              : 
DIV                  : 34
DOT                  : 8
DUB_DOT              : 76
ELSE                 : 70
ELSIF                : 69
END                  : 12 13 66 75
EQUALS               : 50
FOR                  : 76
FUNC                 : 12
GREATER              : 52
GTEQ                 : 54
IDENT                : 8 9 12 12 13 13 18 27 37 46 49 65 76
IF                   : 66 66
IN                   : 76
IS                   : 12 13
LEFT_CUR_PAR         : 
LEFT_PAR             : 14 36 44
LEFT_SQ_PAR          : 
LESS                 : 53
LOOP                 : 75 75
LSEQ                 : 55
MINUS                : 31
MOD                  : 
MUL                  : 33
NOT                  : 42
NOT_EQUALS           : 51
NULL                 : 
NUMBER               : 38 48
OF                   : 
OR                   : 40
PLUS                 : 30
POW                  : 
PROC                 : 13
QUOTE                : 
RETURN               : 12 64
REVERSE              : 
RIGHT_CUR_PAR        : 
RIGHT_PAR            : 14 36 44
RIGHT_SQ_PAR         : 
SEMICOLON            : 6 7 7 12 13 27 64 65 66 75
THEN                 : 66 69
TYPE_BOOL            : 21
TYPE_FLOAT           : 20
TYPE_INT             : 19
USE                  : 7
WHILE                : 77
WITH                 : 6 7
XOR                  : 
error                : 

Nonterminals, with rules where they appear

arg                  : 16 17
args                 : 14 16
args_opt             : 12 13
assign               : 58
bool                 : 42 43
bool_expr            : 29 44 66 69 77
bool_term            : 39 39 40 40 41
declaration          : 22 23
declarations         : 12 13 22
else                 : 66
elsif                : 67
elsifs               : 66 67
empty                : 15 24 68 71
expr                 : 28 30 31 36 76 76
factor               : 33 34 35
for_range            : 73
function             : 11 25
header               : 4 5
headers              : 3 4
if                   : 59
loop                 : 60
loop_body            : 72 73 74
pkg                  : 6 7 7 8
procedure            : 10 26
prog                 : 0
rel_operand          : 47 47
rel_operator         : 47
ret_statement        : 61 62
ret_statements       : 12 61 66 69 70
statement            : 56 57 63
statements           : 13 56 75
subprogram           : 2 3
term                 : 30 31 32 33 34
type                 : 12 18 27
value                : 27 64 65
while                : 74

Parsing method: LALR

state 0

    (0) S' -> . prog
    (2) prog -> . subprogram
    (3) prog -> . headers subprogram
    (10) subprogram -> . procedure
    (11) subprogram -> . function
    (4) headers -> . headers header
    (5) headers -> . header
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (6) header -> . WITH pkg SEMICOLON
    (7) header -> . WITH pkg SEMICOLON USE pkg SEMICOLON

    PROC            shift and go to state 7
    FUNC            shift and go to state 8
    WITH            shift and go to state 9

    prog                           shift and go to state 1
    subprogram                     shift and go to state 2
    headers                        shift and go to state 3
    procedure                      shift and go to state 4
    function                       shift and go to state 5
    header                         shift and go to state 6

state 1

    (0) S' -> prog .



state 2

    (2) prog -> subprogram .

    $end            reduce using rule 2 (prog -> subprogram .)


state 3

    (3) prog -> headers . subprogram
    (4) headers -> headers . header
    (10) subprogram -> . procedure
    (11) subprogram -> . function
    (6) header -> . WITH pkg SEMICOLON
    (7) header -> . WITH pkg SEMICOLON USE pkg SEMICOLON
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON

    WITH            shift and go to state 9
    PROC            shift and go to state 7
    FUNC            shift and go to state 8

    subprogram                     shift and go to state 10
    header                         shift and go to state 11
    procedure                      shift and go to state 4
    function                       shift and go to state 5

state 4

    (10) subprogram -> procedure .

    $end            reduce using rule 10 (subprogram -> procedure .)


state 5

    (11) subprogram -> function .

    $end            reduce using rule 11 (subprogram -> function .)


state 6

    (5) headers -> header .

    WITH            reduce using rule 5 (headers -> header .)
    PROC            reduce using rule 5 (headers -> header .)
    FUNC            reduce using rule 5 (headers -> header .)


state 7

    (13) procedure -> PROC . IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

    IDENT           shift and go to state 12


state 8

    (12) function -> FUNC . IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON

    IDENT           shift and go to state 13


state 9

    (6) header -> WITH . pkg SEMICOLON
    (7) header -> WITH . pkg SEMICOLON USE pkg SEMICOLON
    (8) pkg -> . pkg DOT IDENT
    (9) pkg -> . IDENT

    IDENT           shift and go to state 15

    pkg                            shift and go to state 14

state 10

    (3) prog -> headers subprogram .

    $end            reduce using rule 3 (prog -> headers subprogram .)


state 11

    (4) headers -> headers header .

    WITH            reduce using rule 4 (headers -> headers header .)
    PROC            reduce using rule 4 (headers -> headers header .)
    FUNC            reduce using rule 4 (headers -> headers header .)


state 12

    (13) procedure -> PROC IDENT . args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (14) args_opt -> . LEFT_PAR args RIGHT_PAR
    (15) args_opt -> . empty
    (1) empty -> .

    LEFT_PAR        shift and go to state 17
    IS              reduce using rule 1 (empty -> .)

    args_opt                       shift and go to state 16
    empty                          shift and go to state 18

state 13

    (12) function -> FUNC IDENT . args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (14) args_opt -> . LEFT_PAR args RIGHT_PAR
    (15) args_opt -> . empty
    (1) empty -> .

    LEFT_PAR        shift and go to state 17
    RETURN          reduce using rule 1 (empty -> .)

    args_opt                       shift and go to state 19
    empty                          shift and go to state 18

state 14

    (6) header -> WITH pkg . SEMICOLON
    (7) header -> WITH pkg . SEMICOLON USE pkg SEMICOLON
    (8) pkg -> pkg . DOT IDENT

    SEMICOLON       shift and go to state 20
    DOT             shift and go to state 21


state 15

    (9) pkg -> IDENT .

    SEMICOLON       reduce using rule 9 (pkg -> IDENT .)
    DOT             reduce using rule 9 (pkg -> IDENT .)


state 16

    (13) procedure -> PROC IDENT args_opt . IS declarations BEGIN statements END IDENT SEMICOLON

    IS              shift and go to state 22


state 17

    (14) args_opt -> LEFT_PAR . args RIGHT_PAR
    (16) args -> . args COMMA arg
    (17) args -> . arg
    (18) arg -> . IDENT COLON type

    IDENT           shift and go to state 25

    args                           shift and go to state 23
    arg                            shift and go to state 24

state 18

    (15) args_opt -> empty .

    IS              reduce using rule 15 (args_opt -> empty .)
    RETURN          reduce using rule 15 (args_opt -> empty .)


state 19

    (12) function -> FUNC IDENT args_opt . RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON

    RETURN          shift and go to state 26


state 20

    (6) header -> WITH pkg SEMICOLON .
    (7) header -> WITH pkg SEMICOLON . USE pkg SEMICOLON

    WITH            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    PROC            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    FUNC            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    USE             shift and go to state 27


state 21

    (8) pkg -> pkg DOT . IDENT

    IDENT           shift and go to state 28


state 22

    (13) procedure -> PROC IDENT args_opt IS . declarations BEGIN statements END IDENT SEMICOLON
    (22) declarations -> . declarations declaration
    (23) declarations -> . declaration
    (24) declaration -> . empty
    (25) declaration -> . function
    (26) declaration -> . procedure
    (27) declaration -> . IDENT COLON type ASSIGN value SEMICOLON
    (1) empty -> .
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PROC resolved as shift
    IDENT           shift and go to state 29
    BEGIN           reduce using rule 1 (empty -> .)
    FUNC            shift and go to state 8
    PROC            shift and go to state 7

  ! IDENT           [ reduce using rule 1 (empty -> .) ]
  ! FUNC            [ reduce using rule 1 (empty -> .) ]
  ! PROC            [ reduce using rule 1 (empty -> .) ]

    declarations                   shift and go to state 30
    declaration                    shift and go to state 31
    empty                          shift and go to state 32
    function                       shift and go to state 33
    procedure                      shift and go to state 34

state 23

    (14) args_opt -> LEFT_PAR args . RIGHT_PAR
    (16) args -> args . COMMA arg

    RIGHT_PAR       shift and go to state 35
    COMMA           shift and go to state 36


state 24

    (17) args -> arg .

    RIGHT_PAR       reduce using rule 17 (args -> arg .)
    COMMA           reduce using rule 17 (args -> arg .)


state 25

    (18) arg -> IDENT . COLON type

    COLON           shift and go to state 37


state 26

    (12) function -> FUNC IDENT args_opt RETURN . type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (19) type -> . TYPE_INT
    (20) type -> . TYPE_FLOAT
    (21) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 39
    TYPE_FLOAT      shift and go to state 40
    TYPE_BOOL       shift and go to state 41

    type                           shift and go to state 38

state 27

    (7) header -> WITH pkg SEMICOLON USE . pkg SEMICOLON
    (8) pkg -> . pkg DOT IDENT
    (9) pkg -> . IDENT

    IDENT           shift and go to state 15

    pkg                            shift and go to state 42

state 28

    (8) pkg -> pkg DOT IDENT .

    SEMICOLON       reduce using rule 8 (pkg -> pkg DOT IDENT .)
    DOT             reduce using rule 8 (pkg -> pkg DOT IDENT .)


state 29

    (27) declaration -> IDENT . COLON type ASSIGN value SEMICOLON

    COLON           shift and go to state 43


state 30

    (13) procedure -> PROC IDENT args_opt IS declarations . BEGIN statements END IDENT SEMICOLON
    (22) declarations -> declarations . declaration
    (24) declaration -> . empty
    (25) declaration -> . function
    (26) declaration -> . procedure
    (27) declaration -> . IDENT COLON type ASSIGN value SEMICOLON
    (1) empty -> .
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PROC resolved as shift
    BEGIN           shift and go to state 44
    IDENT           shift and go to state 29
    FUNC            shift and go to state 8
    PROC            shift and go to state 7

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! IDENT           [ reduce using rule 1 (empty -> .) ]
  ! FUNC            [ reduce using rule 1 (empty -> .) ]
  ! PROC            [ reduce using rule 1 (empty -> .) ]

    declaration                    shift and go to state 45
    empty                          shift and go to state 32
    function                       shift and go to state 33
    procedure                      shift and go to state 34

state 31

    (23) declarations -> declaration .

    BEGIN           reduce using rule 23 (declarations -> declaration .)
    IDENT           reduce using rule 23 (declarations -> declaration .)
    FUNC            reduce using rule 23 (declarations -> declaration .)
    PROC            reduce using rule 23 (declarations -> declaration .)


state 32

    (24) declaration -> empty .

    BEGIN           reduce using rule 24 (declaration -> empty .)
    IDENT           reduce using rule 24 (declaration -> empty .)
    FUNC            reduce using rule 24 (declaration -> empty .)
    PROC            reduce using rule 24 (declaration -> empty .)


state 33

    (25) declaration -> function .

    BEGIN           reduce using rule 25 (declaration -> function .)
    IDENT           reduce using rule 25 (declaration -> function .)
    FUNC            reduce using rule 25 (declaration -> function .)
    PROC            reduce using rule 25 (declaration -> function .)


state 34

    (26) declaration -> procedure .

    BEGIN           reduce using rule 26 (declaration -> procedure .)
    IDENT           reduce using rule 26 (declaration -> procedure .)
    FUNC            reduce using rule 26 (declaration -> procedure .)
    PROC            reduce using rule 26 (declaration -> procedure .)


state 35

    (14) args_opt -> LEFT_PAR args RIGHT_PAR .

    IS              reduce using rule 14 (args_opt -> LEFT_PAR args RIGHT_PAR .)
    RETURN          reduce using rule 14 (args_opt -> LEFT_PAR args RIGHT_PAR .)


state 36

    (16) args -> args COMMA . arg
    (18) arg -> . IDENT COLON type

    IDENT           shift and go to state 25

    arg                            shift and go to state 46

state 37

    (18) arg -> IDENT COLON . type
    (19) type -> . TYPE_INT
    (20) type -> . TYPE_FLOAT
    (21) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 39
    TYPE_FLOAT      shift and go to state 40
    TYPE_BOOL       shift and go to state 41

    type                           shift and go to state 47

state 38

    (12) function -> FUNC IDENT args_opt RETURN type . IS declarations BEGIN ret_statements END IDENT SEMICOLON

    IS              shift and go to state 48


state 39

    (19) type -> TYPE_INT .

    IS              reduce using rule 19 (type -> TYPE_INT .)
    RIGHT_PAR       reduce using rule 19 (type -> TYPE_INT .)
    COMMA           reduce using rule 19 (type -> TYPE_INT .)
    ASSIGN          reduce using rule 19 (type -> TYPE_INT .)


state 40

    (20) type -> TYPE_FLOAT .

    IS              reduce using rule 20 (type -> TYPE_FLOAT .)
    RIGHT_PAR       reduce using rule 20 (type -> TYPE_FLOAT .)
    COMMA           reduce using rule 20 (type -> TYPE_FLOAT .)
    ASSIGN          reduce using rule 20 (type -> TYPE_FLOAT .)


state 41

    (21) type -> TYPE_BOOL .

    IS              reduce using rule 21 (type -> TYPE_BOOL .)
    RIGHT_PAR       reduce using rule 21 (type -> TYPE_BOOL .)
    COMMA           reduce using rule 21 (type -> TYPE_BOOL .)
    ASSIGN          reduce using rule 21 (type -> TYPE_BOOL .)


state 42

    (7) header -> WITH pkg SEMICOLON USE pkg . SEMICOLON
    (8) pkg -> pkg . DOT IDENT

    SEMICOLON       shift and go to state 49
    DOT             shift and go to state 21


state 43

    (27) declaration -> IDENT COLON . type ASSIGN value SEMICOLON
    (19) type -> . TYPE_INT
    (20) type -> . TYPE_FLOAT
    (21) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 39
    TYPE_FLOAT      shift and go to state 40
    TYPE_BOOL       shift and go to state 41

    type                           shift and go to state 50

state 44

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN . statements END IDENT SEMICOLON
    (56) statements -> . statements statement
    (57) statements -> . statement
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    statements                     shift and go to state 52
    statement                      shift and go to state 53
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 45

    (22) declarations -> declarations declaration .

    BEGIN           reduce using rule 22 (declarations -> declarations declaration .)
    IDENT           reduce using rule 22 (declarations -> declarations declaration .)
    FUNC            reduce using rule 22 (declarations -> declarations declaration .)
    PROC            reduce using rule 22 (declarations -> declarations declaration .)


state 46

    (16) args -> args COMMA arg .

    RIGHT_PAR       reduce using rule 16 (args -> args COMMA arg .)
    COMMA           reduce using rule 16 (args -> args COMMA arg .)


state 47

    (18) arg -> IDENT COLON type .

    RIGHT_PAR       reduce using rule 18 (arg -> IDENT COLON type .)
    COMMA           reduce using rule 18 (arg -> IDENT COLON type .)


state 48

    (12) function -> FUNC IDENT args_opt RETURN type IS . declarations BEGIN ret_statements END IDENT SEMICOLON
    (22) declarations -> . declarations declaration
    (23) declarations -> . declaration
    (24) declaration -> . empty
    (25) declaration -> . function
    (26) declaration -> . procedure
    (27) declaration -> . IDENT COLON type ASSIGN value SEMICOLON
    (1) empty -> .
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PROC resolved as shift
    IDENT           shift and go to state 29
    BEGIN           reduce using rule 1 (empty -> .)
    FUNC            shift and go to state 8
    PROC            shift and go to state 7

  ! IDENT           [ reduce using rule 1 (empty -> .) ]
  ! FUNC            [ reduce using rule 1 (empty -> .) ]
  ! PROC            [ reduce using rule 1 (empty -> .) ]

    declarations                   shift and go to state 64
    declaration                    shift and go to state 31
    empty                          shift and go to state 32
    function                       shift and go to state 33
    procedure                      shift and go to state 34

state 49

    (7) header -> WITH pkg SEMICOLON USE pkg SEMICOLON .

    WITH            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)
    PROC            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)
    FUNC            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)


state 50

    (27) declaration -> IDENT COLON type . ASSIGN value SEMICOLON

    ASSIGN          shift and go to state 65


state 51

    (65) assign -> IDENT . ASSIGN value SEMICOLON

    ASSIGN          shift and go to state 66


state 52

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements . END IDENT SEMICOLON
    (56) statements -> statements . statement
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    END             shift and go to state 67
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    statement                      shift and go to state 68
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 53

    (57) statements -> statement .

    END             reduce using rule 57 (statements -> statement .)
    IDENT           reduce using rule 57 (statements -> statement .)
    IF              reduce using rule 57 (statements -> statement .)
    LOOP            reduce using rule 57 (statements -> statement .)
    FOR             reduce using rule 57 (statements -> statement .)
    WHILE           reduce using rule 57 (statements -> statement .)


state 54

    (58) statement -> assign .

    END             reduce using rule 58 (statement -> assign .)
    IDENT           reduce using rule 58 (statement -> assign .)
    IF              reduce using rule 58 (statement -> assign .)
    LOOP            reduce using rule 58 (statement -> assign .)
    FOR             reduce using rule 58 (statement -> assign .)
    WHILE           reduce using rule 58 (statement -> assign .)
    RETURN          reduce using rule 58 (statement -> assign .)
    ELSE            reduce using rule 58 (statement -> assign .)
    ELSIF           reduce using rule 58 (statement -> assign .)


state 55

    (59) statement -> if .

    END             reduce using rule 59 (statement -> if .)
    IDENT           reduce using rule 59 (statement -> if .)
    IF              reduce using rule 59 (statement -> if .)
    LOOP            reduce using rule 59 (statement -> if .)
    FOR             reduce using rule 59 (statement -> if .)
    WHILE           reduce using rule 59 (statement -> if .)
    RETURN          reduce using rule 59 (statement -> if .)
    ELSE            reduce using rule 59 (statement -> if .)
    ELSIF           reduce using rule 59 (statement -> if .)


state 56

    (60) statement -> loop .

    END             reduce using rule 60 (statement -> loop .)
    IDENT           reduce using rule 60 (statement -> loop .)
    IF              reduce using rule 60 (statement -> loop .)
    LOOP            reduce using rule 60 (statement -> loop .)
    FOR             reduce using rule 60 (statement -> loop .)
    WHILE           reduce using rule 60 (statement -> loop .)
    RETURN          reduce using rule 60 (statement -> loop .)
    ELSE            reduce using rule 60 (statement -> loop .)
    ELSIF           reduce using rule 60 (statement -> loop .)


state 57

    (66) if -> IF . bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (39) bool_expr -> . bool_term AND bool_term
    (40) bool_expr -> . bool_term OR bool_term
    (41) bool_expr -> . bool_term
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 73
    BOOL_VAL        shift and go to state 74
    IDENT           shift and go to state 75
    NUMBER          shift and go to state 77

    bool_expr                      shift and go to state 69
    bool_term                      shift and go to state 70
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 58

    (72) loop -> loop_body .

    END             reduce using rule 72 (loop -> loop_body .)
    IDENT           reduce using rule 72 (loop -> loop_body .)
    IF              reduce using rule 72 (loop -> loop_body .)
    LOOP            reduce using rule 72 (loop -> loop_body .)
    FOR             reduce using rule 72 (loop -> loop_body .)
    WHILE           reduce using rule 72 (loop -> loop_body .)
    RETURN          reduce using rule 72 (loop -> loop_body .)
    ELSE            reduce using rule 72 (loop -> loop_body .)
    ELSIF           reduce using rule 72 (loop -> loop_body .)


state 59

    (73) loop -> for_range . loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON

    LOOP            shift and go to state 61

    loop_body                      shift and go to state 78

state 60

    (74) loop -> while . loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON

    LOOP            shift and go to state 61

    loop_body                      shift and go to state 79

state 61

    (75) loop_body -> LOOP . statements END LOOP SEMICOLON
    (56) statements -> . statements statement
    (57) statements -> . statement
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    statements                     shift and go to state 80
    statement                      shift and go to state 53
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 62

    (76) for_range -> FOR . IDENT IN expr DUB_DOT expr

    IDENT           shift and go to state 81


state 63

    (77) while -> WHILE . bool_expr
    (39) bool_expr -> . bool_term AND bool_term
    (40) bool_expr -> . bool_term OR bool_term
    (41) bool_expr -> . bool_term
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 73
    BOOL_VAL        shift and go to state 74
    IDENT           shift and go to state 75
    NUMBER          shift and go to state 77

    bool_expr                      shift and go to state 82
    bool_term                      shift and go to state 70
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 64

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations . BEGIN ret_statements END IDENT SEMICOLON
    (22) declarations -> declarations . declaration
    (24) declaration -> . empty
    (25) declaration -> . function
    (26) declaration -> . procedure
    (27) declaration -> . IDENT COLON type ASSIGN value SEMICOLON
    (1) empty -> .
    (12) function -> . FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IDENT resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PROC resolved as shift
    BEGIN           shift and go to state 83
    IDENT           shift and go to state 29
    FUNC            shift and go to state 8
    PROC            shift and go to state 7

  ! BEGIN           [ reduce using rule 1 (empty -> .) ]
  ! IDENT           [ reduce using rule 1 (empty -> .) ]
  ! FUNC            [ reduce using rule 1 (empty -> .) ]
  ! PROC            [ reduce using rule 1 (empty -> .) ]

    declaration                    shift and go to state 45
    empty                          shift and go to state 32
    function                       shift and go to state 33
    procedure                      shift and go to state 34

state 65

    (27) declaration -> IDENT COLON type ASSIGN . value SEMICOLON
    (28) value -> . expr
    (29) value -> . bool_expr
    (30) expr -> . expr PLUS term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (39) bool_expr -> . bool_term AND bool_term
    (40) bool_expr -> . bool_term OR bool_term
    (41) bool_expr -> . bool_term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 90
    IDENT           shift and go to state 84
    NUMBER          shift and go to state 91
    BOOL_VAL        shift and go to state 74

    value                          shift and go to state 85
    expr                           shift and go to state 86
    bool_expr                      shift and go to state 87
    term                           shift and go to state 88
    bool_term                      shift and go to state 70
    factor                         shift and go to state 89
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 66

    (65) assign -> IDENT ASSIGN . value SEMICOLON
    (28) value -> . expr
    (29) value -> . bool_expr
    (30) expr -> . expr PLUS term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (39) bool_expr -> . bool_term AND bool_term
    (40) bool_expr -> . bool_term OR bool_term
    (41) bool_expr -> . bool_term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 90
    IDENT           shift and go to state 84
    NUMBER          shift and go to state 91
    BOOL_VAL        shift and go to state 74

    value                          shift and go to state 92
    expr                           shift and go to state 86
    bool_expr                      shift and go to state 87
    term                           shift and go to state 88
    bool_term                      shift and go to state 70
    factor                         shift and go to state 89
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 67

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END . IDENT SEMICOLON

    IDENT           shift and go to state 93


state 68

    (56) statements -> statements statement .

    END             reduce using rule 56 (statements -> statements statement .)
    IDENT           reduce using rule 56 (statements -> statements statement .)
    IF              reduce using rule 56 (statements -> statements statement .)
    LOOP            reduce using rule 56 (statements -> statements statement .)
    FOR             reduce using rule 56 (statements -> statements statement .)
    WHILE           reduce using rule 56 (statements -> statements statement .)


state 69

    (66) if -> IF bool_expr . THEN ret_statements elsifs else END IF SEMICOLON

    THEN            shift and go to state 94


state 70

    (39) bool_expr -> bool_term . AND bool_term
    (40) bool_expr -> bool_term . OR bool_term
    (41) bool_expr -> bool_term .

    AND             shift and go to state 95
    OR              shift and go to state 96
    THEN            reduce using rule 41 (bool_expr -> bool_term .)
    LOOP            reduce using rule 41 (bool_expr -> bool_term .)
    SEMICOLON       reduce using rule 41 (bool_expr -> bool_term .)
    RIGHT_PAR       reduce using rule 41 (bool_expr -> bool_term .)


state 71

    (42) bool_term -> NOT . bool
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    LEFT_PAR        shift and go to state 73
    BOOL_VAL        shift and go to state 74
    IDENT           shift and go to state 75
    NUMBER          shift and go to state 77

    bool                           shift and go to state 97
    rel_operand                    shift and go to state 76

state 72

    (43) bool_term -> bool .

    AND             reduce using rule 43 (bool_term -> bool .)
    OR              reduce using rule 43 (bool_term -> bool .)
    THEN            reduce using rule 43 (bool_term -> bool .)
    LOOP            reduce using rule 43 (bool_term -> bool .)
    SEMICOLON       reduce using rule 43 (bool_term -> bool .)
    RIGHT_PAR       reduce using rule 43 (bool_term -> bool .)


state 73

    (44) bool -> LEFT_PAR . bool_expr RIGHT_PAR
    (39) bool_expr -> . bool_term AND bool_term
    (40) bool_expr -> . bool_term OR bool_term
    (41) bool_expr -> . bool_term
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 73
    BOOL_VAL        shift and go to state 74
    IDENT           shift and go to state 75
    NUMBER          shift and go to state 77

    bool_expr                      shift and go to state 98
    bool_term                      shift and go to state 70
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 74

    (45) bool -> BOOL_VAL .

    AND             reduce using rule 45 (bool -> BOOL_VAL .)
    OR              reduce using rule 45 (bool -> BOOL_VAL .)
    THEN            reduce using rule 45 (bool -> BOOL_VAL .)
    LOOP            reduce using rule 45 (bool -> BOOL_VAL .)
    SEMICOLON       reduce using rule 45 (bool -> BOOL_VAL .)
    RIGHT_PAR       reduce using rule 45 (bool -> BOOL_VAL .)


state 75

    (46) bool -> IDENT .
    (49) rel_operand -> IDENT .

    AND             reduce using rule 46 (bool -> IDENT .)
    OR              reduce using rule 46 (bool -> IDENT .)
    THEN            reduce using rule 46 (bool -> IDENT .)
    LOOP            reduce using rule 46 (bool -> IDENT .)
    SEMICOLON       reduce using rule 46 (bool -> IDENT .)
    RIGHT_PAR       reduce using rule 46 (bool -> IDENT .)
    EQUALS          reduce using rule 49 (rel_operand -> IDENT .)
    NOT_EQUALS      reduce using rule 49 (rel_operand -> IDENT .)
    GREATER         reduce using rule 49 (rel_operand -> IDENT .)
    LESS            reduce using rule 49 (rel_operand -> IDENT .)
    GTEQ            reduce using rule 49 (rel_operand -> IDENT .)
    LSEQ            reduce using rule 49 (rel_operand -> IDENT .)


state 76

    (47) bool -> rel_operand . rel_operator rel_operand
    (50) rel_operator -> . EQUALS
    (51) rel_operator -> . NOT_EQUALS
    (52) rel_operator -> . GREATER
    (53) rel_operator -> . LESS
    (54) rel_operator -> . GTEQ
    (55) rel_operator -> . LSEQ

    EQUALS          shift and go to state 100
    NOT_EQUALS      shift and go to state 101
    GREATER         shift and go to state 102
    LESS            shift and go to state 103
    GTEQ            shift and go to state 104
    LSEQ            shift and go to state 105

    rel_operator                   shift and go to state 99

state 77

    (48) rel_operand -> NUMBER .

    EQUALS          reduce using rule 48 (rel_operand -> NUMBER .)
    NOT_EQUALS      reduce using rule 48 (rel_operand -> NUMBER .)
    GREATER         reduce using rule 48 (rel_operand -> NUMBER .)
    LESS            reduce using rule 48 (rel_operand -> NUMBER .)
    GTEQ            reduce using rule 48 (rel_operand -> NUMBER .)
    LSEQ            reduce using rule 48 (rel_operand -> NUMBER .)
    AND             reduce using rule 48 (rel_operand -> NUMBER .)
    OR              reduce using rule 48 (rel_operand -> NUMBER .)
    THEN            reduce using rule 48 (rel_operand -> NUMBER .)
    LOOP            reduce using rule 48 (rel_operand -> NUMBER .)
    SEMICOLON       reduce using rule 48 (rel_operand -> NUMBER .)
    RIGHT_PAR       reduce using rule 48 (rel_operand -> NUMBER .)


state 78

    (73) loop -> for_range loop_body .

    END             reduce using rule 73 (loop -> for_range loop_body .)
    IDENT           reduce using rule 73 (loop -> for_range loop_body .)
    IF              reduce using rule 73 (loop -> for_range loop_body .)
    LOOP            reduce using rule 73 (loop -> for_range loop_body .)
    FOR             reduce using rule 73 (loop -> for_range loop_body .)
    WHILE           reduce using rule 73 (loop -> for_range loop_body .)
    RETURN          reduce using rule 73 (loop -> for_range loop_body .)
    ELSE            reduce using rule 73 (loop -> for_range loop_body .)
    ELSIF           reduce using rule 73 (loop -> for_range loop_body .)


state 79

    (74) loop -> while loop_body .

    END             reduce using rule 74 (loop -> while loop_body .)
    IDENT           reduce using rule 74 (loop -> while loop_body .)
    IF              reduce using rule 74 (loop -> while loop_body .)
    LOOP            reduce using rule 74 (loop -> while loop_body .)
    FOR             reduce using rule 74 (loop -> while loop_body .)
    WHILE           reduce using rule 74 (loop -> while loop_body .)
    RETURN          reduce using rule 74 (loop -> while loop_body .)
    ELSE            reduce using rule 74 (loop -> while loop_body .)
    ELSIF           reduce using rule 74 (loop -> while loop_body .)


state 80

    (75) loop_body -> LOOP statements . END LOOP SEMICOLON
    (56) statements -> statements . statement
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    END             shift and go to state 106
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    statement                      shift and go to state 68
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 81

    (76) for_range -> FOR IDENT . IN expr DUB_DOT expr

    IN              shift and go to state 107


state 82

    (77) while -> WHILE bool_expr .

    LOOP            reduce using rule 77 (while -> WHILE bool_expr .)


state 83

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN . ret_statements END IDENT SEMICOLON
    (61) ret_statements -> . ret_statements ret_statement
    (62) ret_statements -> . ret_statement
    (63) ret_statement -> . statement
    (64) ret_statement -> . RETURN value SEMICOLON
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    RETURN          shift and go to state 108
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    ret_statements                 shift and go to state 109
    ret_statement                  shift and go to state 110
    statement                      shift and go to state 111
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 84

    (37) factor -> IDENT .
    (46) bool -> IDENT .
    (49) rel_operand -> IDENT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 37 (factor -> IDENT .)
  ! reduce/reduce conflict for RIGHT_PAR resolved using rule 37 (factor -> IDENT .)
    MUL             reduce using rule 37 (factor -> IDENT .)
    DIV             reduce using rule 37 (factor -> IDENT .)
    PLUS            reduce using rule 37 (factor -> IDENT .)
    MINUS           reduce using rule 37 (factor -> IDENT .)
    SEMICOLON       reduce using rule 37 (factor -> IDENT .)
    RIGHT_PAR       reduce using rule 37 (factor -> IDENT .)
    AND             reduce using rule 46 (bool -> IDENT .)
    OR              reduce using rule 46 (bool -> IDENT .)
    EQUALS          reduce using rule 49 (rel_operand -> IDENT .)
    NOT_EQUALS      reduce using rule 49 (rel_operand -> IDENT .)
    GREATER         reduce using rule 49 (rel_operand -> IDENT .)
    LESS            reduce using rule 49 (rel_operand -> IDENT .)
    GTEQ            reduce using rule 49 (rel_operand -> IDENT .)
    LSEQ            reduce using rule 49 (rel_operand -> IDENT .)

  ! SEMICOLON       [ reduce using rule 46 (bool -> IDENT .) ]
  ! RIGHT_PAR       [ reduce using rule 46 (bool -> IDENT .) ]


state 85

    (27) declaration -> IDENT COLON type ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 112


state 86

    (28) value -> expr .
    (30) expr -> expr . PLUS term
    (31) expr -> expr . MINUS term

    SEMICOLON       reduce using rule 28 (value -> expr .)
    PLUS            shift and go to state 113
    MINUS           shift and go to state 114


state 87

    (29) value -> bool_expr .

    SEMICOLON       reduce using rule 29 (value -> bool_expr .)


state 88

    (32) expr -> term .
    (33) term -> term . MUL factor
    (34) term -> term . DIV factor

    PLUS            reduce using rule 32 (expr -> term .)
    MINUS           reduce using rule 32 (expr -> term .)
    SEMICOLON       reduce using rule 32 (expr -> term .)
    RIGHT_PAR       reduce using rule 32 (expr -> term .)
    DUB_DOT         reduce using rule 32 (expr -> term .)
    LOOP            reduce using rule 32 (expr -> term .)
    MUL             shift and go to state 115
    DIV             shift and go to state 116


state 89

    (35) term -> factor .

    MUL             reduce using rule 35 (term -> factor .)
    DIV             reduce using rule 35 (term -> factor .)
    PLUS            reduce using rule 35 (term -> factor .)
    MINUS           reduce using rule 35 (term -> factor .)
    SEMICOLON       reduce using rule 35 (term -> factor .)
    RIGHT_PAR       reduce using rule 35 (term -> factor .)
    DUB_DOT         reduce using rule 35 (term -> factor .)
    LOOP            reduce using rule 35 (term -> factor .)


state 90

    (36) factor -> LEFT_PAR . expr RIGHT_PAR
    (44) bool -> LEFT_PAR . bool_expr RIGHT_PAR
    (30) expr -> . expr PLUS term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (39) bool_expr -> . bool_term AND bool_term
    (40) bool_expr -> . bool_term OR bool_term
    (41) bool_expr -> . bool_term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 90
    IDENT           shift and go to state 84
    NUMBER          shift and go to state 91
    BOOL_VAL        shift and go to state 74

    expr                           shift and go to state 117
    bool_expr                      shift and go to state 98
    term                           shift and go to state 88
    bool_term                      shift and go to state 70
    factor                         shift and go to state 89
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 91

    (38) factor -> NUMBER .
    (48) rel_operand -> NUMBER .

    MUL             reduce using rule 38 (factor -> NUMBER .)
    DIV             reduce using rule 38 (factor -> NUMBER .)
    PLUS            reduce using rule 38 (factor -> NUMBER .)
    MINUS           reduce using rule 38 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 38 (factor -> NUMBER .)
    RIGHT_PAR       reduce using rule 38 (factor -> NUMBER .)
    EQUALS          reduce using rule 48 (rel_operand -> NUMBER .)
    NOT_EQUALS      reduce using rule 48 (rel_operand -> NUMBER .)
    GREATER         reduce using rule 48 (rel_operand -> NUMBER .)
    LESS            reduce using rule 48 (rel_operand -> NUMBER .)
    GTEQ            reduce using rule 48 (rel_operand -> NUMBER .)
    LSEQ            reduce using rule 48 (rel_operand -> NUMBER .)


state 92

    (65) assign -> IDENT ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 118


state 93

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT . SEMICOLON

    SEMICOLON       shift and go to state 119


state 94

    (66) if -> IF bool_expr THEN . ret_statements elsifs else END IF SEMICOLON
    (61) ret_statements -> . ret_statements ret_statement
    (62) ret_statements -> . ret_statement
    (63) ret_statement -> . statement
    (64) ret_statement -> . RETURN value SEMICOLON
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    RETURN          shift and go to state 108
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    ret_statements                 shift and go to state 120
    ret_statement                  shift and go to state 110
    statement                      shift and go to state 111
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 95

    (39) bool_expr -> bool_term AND . bool_term
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 73
    BOOL_VAL        shift and go to state 74
    IDENT           shift and go to state 75
    NUMBER          shift and go to state 77

    bool_term                      shift and go to state 121
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 96

    (40) bool_expr -> bool_term OR . bool_term
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 73
    BOOL_VAL        shift and go to state 74
    IDENT           shift and go to state 75
    NUMBER          shift and go to state 77

    bool_term                      shift and go to state 122
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 97

    (42) bool_term -> NOT bool .

    AND             reduce using rule 42 (bool_term -> NOT bool .)
    OR              reduce using rule 42 (bool_term -> NOT bool .)
    THEN            reduce using rule 42 (bool_term -> NOT bool .)
    LOOP            reduce using rule 42 (bool_term -> NOT bool .)
    SEMICOLON       reduce using rule 42 (bool_term -> NOT bool .)
    RIGHT_PAR       reduce using rule 42 (bool_term -> NOT bool .)


state 98

    (44) bool -> LEFT_PAR bool_expr . RIGHT_PAR

    RIGHT_PAR       shift and go to state 123


state 99

    (47) bool -> rel_operand rel_operator . rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NUMBER          shift and go to state 77
    IDENT           shift and go to state 125

    rel_operand                    shift and go to state 124

state 100

    (50) rel_operator -> EQUALS .

    NUMBER          reduce using rule 50 (rel_operator -> EQUALS .)
    IDENT           reduce using rule 50 (rel_operator -> EQUALS .)


state 101

    (51) rel_operator -> NOT_EQUALS .

    NUMBER          reduce using rule 51 (rel_operator -> NOT_EQUALS .)
    IDENT           reduce using rule 51 (rel_operator -> NOT_EQUALS .)


state 102

    (52) rel_operator -> GREATER .

    NUMBER          reduce using rule 52 (rel_operator -> GREATER .)
    IDENT           reduce using rule 52 (rel_operator -> GREATER .)


state 103

    (53) rel_operator -> LESS .

    NUMBER          reduce using rule 53 (rel_operator -> LESS .)
    IDENT           reduce using rule 53 (rel_operator -> LESS .)


state 104

    (54) rel_operator -> GTEQ .

    NUMBER          reduce using rule 54 (rel_operator -> GTEQ .)
    IDENT           reduce using rule 54 (rel_operator -> GTEQ .)


state 105

    (55) rel_operator -> LSEQ .

    NUMBER          reduce using rule 55 (rel_operator -> LSEQ .)
    IDENT           reduce using rule 55 (rel_operator -> LSEQ .)


state 106

    (75) loop_body -> LOOP statements END . LOOP SEMICOLON

    LOOP            shift and go to state 126


state 107

    (76) for_range -> FOR IDENT IN . expr DUB_DOT expr
    (30) expr -> . expr PLUS term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER

    LEFT_PAR        shift and go to state 129
    IDENT           shift and go to state 127
    NUMBER          shift and go to state 130

    expr                           shift and go to state 128
    term                           shift and go to state 88
    factor                         shift and go to state 89

state 108

    (64) ret_statement -> RETURN . value SEMICOLON
    (28) value -> . expr
    (29) value -> . bool_expr
    (30) expr -> . expr PLUS term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (39) bool_expr -> . bool_term AND bool_term
    (40) bool_expr -> . bool_term OR bool_term
    (41) bool_expr -> . bool_term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 90
    IDENT           shift and go to state 84
    NUMBER          shift and go to state 91
    BOOL_VAL        shift and go to state 74

    value                          shift and go to state 131
    expr                           shift and go to state 86
    bool_expr                      shift and go to state 87
    term                           shift and go to state 88
    bool_term                      shift and go to state 70
    factor                         shift and go to state 89
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 109

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements . END IDENT SEMICOLON
    (61) ret_statements -> ret_statements . ret_statement
    (63) ret_statement -> . statement
    (64) ret_statement -> . RETURN value SEMICOLON
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    END             shift and go to state 132
    RETURN          shift and go to state 108
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    ret_statement                  shift and go to state 133
    statement                      shift and go to state 111
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 110

    (62) ret_statements -> ret_statement .

    END             reduce using rule 62 (ret_statements -> ret_statement .)
    RETURN          reduce using rule 62 (ret_statements -> ret_statement .)
    IDENT           reduce using rule 62 (ret_statements -> ret_statement .)
    IF              reduce using rule 62 (ret_statements -> ret_statement .)
    LOOP            reduce using rule 62 (ret_statements -> ret_statement .)
    FOR             reduce using rule 62 (ret_statements -> ret_statement .)
    WHILE           reduce using rule 62 (ret_statements -> ret_statement .)
    ELSE            reduce using rule 62 (ret_statements -> ret_statement .)
    ELSIF           reduce using rule 62 (ret_statements -> ret_statement .)


state 111

    (63) ret_statement -> statement .

    END             reduce using rule 63 (ret_statement -> statement .)
    RETURN          reduce using rule 63 (ret_statement -> statement .)
    IDENT           reduce using rule 63 (ret_statement -> statement .)
    IF              reduce using rule 63 (ret_statement -> statement .)
    LOOP            reduce using rule 63 (ret_statement -> statement .)
    FOR             reduce using rule 63 (ret_statement -> statement .)
    WHILE           reduce using rule 63 (ret_statement -> statement .)
    ELSE            reduce using rule 63 (ret_statement -> statement .)
    ELSIF           reduce using rule 63 (ret_statement -> statement .)


state 112

    (27) declaration -> IDENT COLON type ASSIGN value SEMICOLON .

    BEGIN           reduce using rule 27 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)
    IDENT           reduce using rule 27 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)
    FUNC            reduce using rule 27 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)
    PROC            reduce using rule 27 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)


state 113

    (30) expr -> expr PLUS . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER

    LEFT_PAR        shift and go to state 129
    IDENT           shift and go to state 127
    NUMBER          shift and go to state 130

    term                           shift and go to state 134
    factor                         shift and go to state 89

state 114

    (31) expr -> expr MINUS . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER

    LEFT_PAR        shift and go to state 129
    IDENT           shift and go to state 127
    NUMBER          shift and go to state 130

    term                           shift and go to state 135
    factor                         shift and go to state 89

state 115

    (33) term -> term MUL . factor
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER

    LEFT_PAR        shift and go to state 129
    IDENT           shift and go to state 127
    NUMBER          shift and go to state 130

    factor                         shift and go to state 136

state 116

    (34) term -> term DIV . factor
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER

    LEFT_PAR        shift and go to state 129
    IDENT           shift and go to state 127
    NUMBER          shift and go to state 130

    factor                         shift and go to state 137

state 117

    (36) factor -> LEFT_PAR expr . RIGHT_PAR
    (30) expr -> expr . PLUS term
    (31) expr -> expr . MINUS term

    RIGHT_PAR       shift and go to state 138
    PLUS            shift and go to state 113
    MINUS           shift and go to state 114


state 118

    (65) assign -> IDENT ASSIGN value SEMICOLON .

    END             reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)
    IDENT           reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)
    IF              reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)
    LOOP            reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)
    FOR             reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)
    WHILE           reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)
    RETURN          reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)
    ELSE            reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)
    ELSIF           reduce using rule 65 (assign -> IDENT ASSIGN value SEMICOLON .)


state 119

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .

    $end            reduce using rule 13 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)
    BEGIN           reduce using rule 13 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)
    IDENT           reduce using rule 13 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)
    FUNC            reduce using rule 13 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)
    PROC            reduce using rule 13 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)


state 120

    (66) if -> IF bool_expr THEN ret_statements . elsifs else END IF SEMICOLON
    (61) ret_statements -> ret_statements . ret_statement
    (67) elsifs -> . elsifs elsif
    (68) elsifs -> . empty
    (63) ret_statement -> . statement
    (64) ret_statement -> . RETURN value SEMICOLON
    (1) empty -> .
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    RETURN          shift and go to state 108
    ELSE            reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    elsifs                         shift and go to state 139
    ret_statement                  shift and go to state 133
    empty                          shift and go to state 140
    statement                      shift and go to state 111
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 121

    (39) bool_expr -> bool_term AND bool_term .

    THEN            reduce using rule 39 (bool_expr -> bool_term AND bool_term .)
    LOOP            reduce using rule 39 (bool_expr -> bool_term AND bool_term .)
    SEMICOLON       reduce using rule 39 (bool_expr -> bool_term AND bool_term .)
    RIGHT_PAR       reduce using rule 39 (bool_expr -> bool_term AND bool_term .)


state 122

    (40) bool_expr -> bool_term OR bool_term .

    THEN            reduce using rule 40 (bool_expr -> bool_term OR bool_term .)
    LOOP            reduce using rule 40 (bool_expr -> bool_term OR bool_term .)
    SEMICOLON       reduce using rule 40 (bool_expr -> bool_term OR bool_term .)
    RIGHT_PAR       reduce using rule 40 (bool_expr -> bool_term OR bool_term .)


state 123

    (44) bool -> LEFT_PAR bool_expr RIGHT_PAR .

    AND             reduce using rule 44 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    OR              reduce using rule 44 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    THEN            reduce using rule 44 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    LOOP            reduce using rule 44 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 44 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 44 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)


state 124

    (47) bool -> rel_operand rel_operator rel_operand .

    AND             reduce using rule 47 (bool -> rel_operand rel_operator rel_operand .)
    OR              reduce using rule 47 (bool -> rel_operand rel_operator rel_operand .)
    THEN            reduce using rule 47 (bool -> rel_operand rel_operator rel_operand .)
    LOOP            reduce using rule 47 (bool -> rel_operand rel_operator rel_operand .)
    SEMICOLON       reduce using rule 47 (bool -> rel_operand rel_operator rel_operand .)
    RIGHT_PAR       reduce using rule 47 (bool -> rel_operand rel_operator rel_operand .)


state 125

    (49) rel_operand -> IDENT .

    AND             reduce using rule 49 (rel_operand -> IDENT .)
    OR              reduce using rule 49 (rel_operand -> IDENT .)
    THEN            reduce using rule 49 (rel_operand -> IDENT .)
    LOOP            reduce using rule 49 (rel_operand -> IDENT .)
    SEMICOLON       reduce using rule 49 (rel_operand -> IDENT .)
    RIGHT_PAR       reduce using rule 49 (rel_operand -> IDENT .)


state 126

    (75) loop_body -> LOOP statements END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 141


state 127

    (37) factor -> IDENT .

    MUL             reduce using rule 37 (factor -> IDENT .)
    DIV             reduce using rule 37 (factor -> IDENT .)
    DUB_DOT         reduce using rule 37 (factor -> IDENT .)
    PLUS            reduce using rule 37 (factor -> IDENT .)
    MINUS           reduce using rule 37 (factor -> IDENT .)
    SEMICOLON       reduce using rule 37 (factor -> IDENT .)
    RIGHT_PAR       reduce using rule 37 (factor -> IDENT .)
    LOOP            reduce using rule 37 (factor -> IDENT .)


state 128

    (76) for_range -> FOR IDENT IN expr . DUB_DOT expr
    (30) expr -> expr . PLUS term
    (31) expr -> expr . MINUS term

    DUB_DOT         shift and go to state 142
    PLUS            shift and go to state 113
    MINUS           shift and go to state 114


state 129

    (36) factor -> LEFT_PAR . expr RIGHT_PAR
    (30) expr -> . expr PLUS term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER

    LEFT_PAR        shift and go to state 129
    IDENT           shift and go to state 127
    NUMBER          shift and go to state 130

    expr                           shift and go to state 117
    term                           shift and go to state 88
    factor                         shift and go to state 89

state 130

    (38) factor -> NUMBER .

    MUL             reduce using rule 38 (factor -> NUMBER .)
    DIV             reduce using rule 38 (factor -> NUMBER .)
    DUB_DOT         reduce using rule 38 (factor -> NUMBER .)
    PLUS            reduce using rule 38 (factor -> NUMBER .)
    MINUS           reduce using rule 38 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 38 (factor -> NUMBER .)
    RIGHT_PAR       reduce using rule 38 (factor -> NUMBER .)
    LOOP            reduce using rule 38 (factor -> NUMBER .)


state 131

    (64) ret_statement -> RETURN value . SEMICOLON

    SEMICOLON       shift and go to state 143


state 132

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END . IDENT SEMICOLON

    IDENT           shift and go to state 144


state 133

    (61) ret_statements -> ret_statements ret_statement .

    END             reduce using rule 61 (ret_statements -> ret_statements ret_statement .)
    RETURN          reduce using rule 61 (ret_statements -> ret_statements ret_statement .)
    IDENT           reduce using rule 61 (ret_statements -> ret_statements ret_statement .)
    IF              reduce using rule 61 (ret_statements -> ret_statements ret_statement .)
    LOOP            reduce using rule 61 (ret_statements -> ret_statements ret_statement .)
    FOR             reduce using rule 61 (ret_statements -> ret_statements ret_statement .)
    WHILE           reduce using rule 61 (ret_statements -> ret_statements ret_statement .)
    ELSE            reduce using rule 61 (ret_statements -> ret_statements ret_statement .)
    ELSIF           reduce using rule 61 (ret_statements -> ret_statements ret_statement .)


state 134

    (30) expr -> expr PLUS term .
    (33) term -> term . MUL factor
    (34) term -> term . DIV factor

    PLUS            reduce using rule 30 (expr -> expr PLUS term .)
    MINUS           reduce using rule 30 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 30 (expr -> expr PLUS term .)
    RIGHT_PAR       reduce using rule 30 (expr -> expr PLUS term .)
    DUB_DOT         reduce using rule 30 (expr -> expr PLUS term .)
    LOOP            reduce using rule 30 (expr -> expr PLUS term .)
    MUL             shift and go to state 115
    DIV             shift and go to state 116


state 135

    (31) expr -> expr MINUS term .
    (33) term -> term . MUL factor
    (34) term -> term . DIV factor

    PLUS            reduce using rule 31 (expr -> expr MINUS term .)
    MINUS           reduce using rule 31 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 31 (expr -> expr MINUS term .)
    RIGHT_PAR       reduce using rule 31 (expr -> expr MINUS term .)
    DUB_DOT         reduce using rule 31 (expr -> expr MINUS term .)
    LOOP            reduce using rule 31 (expr -> expr MINUS term .)
    MUL             shift and go to state 115
    DIV             shift and go to state 116


state 136

    (33) term -> term MUL factor .

    MUL             reduce using rule 33 (term -> term MUL factor .)
    DIV             reduce using rule 33 (term -> term MUL factor .)
    PLUS            reduce using rule 33 (term -> term MUL factor .)
    MINUS           reduce using rule 33 (term -> term MUL factor .)
    SEMICOLON       reduce using rule 33 (term -> term MUL factor .)
    RIGHT_PAR       reduce using rule 33 (term -> term MUL factor .)
    DUB_DOT         reduce using rule 33 (term -> term MUL factor .)
    LOOP            reduce using rule 33 (term -> term MUL factor .)


state 137

    (34) term -> term DIV factor .

    MUL             reduce using rule 34 (term -> term DIV factor .)
    DIV             reduce using rule 34 (term -> term DIV factor .)
    PLUS            reduce using rule 34 (term -> term DIV factor .)
    MINUS           reduce using rule 34 (term -> term DIV factor .)
    SEMICOLON       reduce using rule 34 (term -> term DIV factor .)
    RIGHT_PAR       reduce using rule 34 (term -> term DIV factor .)
    DUB_DOT         reduce using rule 34 (term -> term DIV factor .)
    LOOP            reduce using rule 34 (term -> term DIV factor .)


state 138

    (36) factor -> LEFT_PAR expr RIGHT_PAR .

    MUL             reduce using rule 36 (factor -> LEFT_PAR expr RIGHT_PAR .)
    DIV             reduce using rule 36 (factor -> LEFT_PAR expr RIGHT_PAR .)
    PLUS            reduce using rule 36 (factor -> LEFT_PAR expr RIGHT_PAR .)
    MINUS           reduce using rule 36 (factor -> LEFT_PAR expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 36 (factor -> LEFT_PAR expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 36 (factor -> LEFT_PAR expr RIGHT_PAR .)
    DUB_DOT         reduce using rule 36 (factor -> LEFT_PAR expr RIGHT_PAR .)
    LOOP            reduce using rule 36 (factor -> LEFT_PAR expr RIGHT_PAR .)


state 139

    (66) if -> IF bool_expr THEN ret_statements elsifs . else END IF SEMICOLON
    (67) elsifs -> elsifs . elsif
    (70) else -> . ELSE ret_statements
    (71) else -> . empty
    (69) elsif -> . ELSIF bool_expr THEN ret_statements
    (1) empty -> .

    ELSE            shift and go to state 147
    ELSIF           shift and go to state 149
    END             reduce using rule 1 (empty -> .)

    else                           shift and go to state 145
    elsif                          shift and go to state 146
    empty                          shift and go to state 148

state 140

    (68) elsifs -> empty .

    ELSE            reduce using rule 68 (elsifs -> empty .)
    ELSIF           reduce using rule 68 (elsifs -> empty .)
    END             reduce using rule 68 (elsifs -> empty .)


state 141

    (75) loop_body -> LOOP statements END LOOP SEMICOLON .

    END             reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    IDENT           reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    IF              reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    LOOP            reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    FOR             reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    WHILE           reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    RETURN          reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    ELSE            reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    ELSIF           reduce using rule 75 (loop_body -> LOOP statements END LOOP SEMICOLON .)


state 142

    (76) for_range -> FOR IDENT IN expr DUB_DOT . expr
    (30) expr -> . expr PLUS term
    (31) expr -> . expr MINUS term
    (32) expr -> . term
    (33) term -> . term MUL factor
    (34) term -> . term DIV factor
    (35) term -> . factor
    (36) factor -> . LEFT_PAR expr RIGHT_PAR
    (37) factor -> . IDENT
    (38) factor -> . NUMBER

    LEFT_PAR        shift and go to state 129
    IDENT           shift and go to state 127
    NUMBER          shift and go to state 130

    expr                           shift and go to state 150
    term                           shift and go to state 88
    factor                         shift and go to state 89

state 143

    (64) ret_statement -> RETURN value SEMICOLON .

    END             reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)
    RETURN          reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)
    IDENT           reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)
    IF              reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)
    LOOP            reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)
    FOR             reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)
    WHILE           reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)
    ELSE            reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)
    ELSIF           reduce using rule 64 (ret_statement -> RETURN value SEMICOLON .)


state 144

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT . SEMICOLON

    SEMICOLON       shift and go to state 151


state 145

    (66) if -> IF bool_expr THEN ret_statements elsifs else . END IF SEMICOLON

    END             shift and go to state 152


state 146

    (67) elsifs -> elsifs elsif .

    ELSE            reduce using rule 67 (elsifs -> elsifs elsif .)
    ELSIF           reduce using rule 67 (elsifs -> elsifs elsif .)
    END             reduce using rule 67 (elsifs -> elsifs elsif .)


state 147

    (70) else -> ELSE . ret_statements
    (61) ret_statements -> . ret_statements ret_statement
    (62) ret_statements -> . ret_statement
    (63) ret_statement -> . statement
    (64) ret_statement -> . RETURN value SEMICOLON
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    RETURN          shift and go to state 108
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    ret_statements                 shift and go to state 153
    ret_statement                  shift and go to state 110
    statement                      shift and go to state 111
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 148

    (71) else -> empty .

    END             reduce using rule 71 (else -> empty .)


state 149

    (69) elsif -> ELSIF . bool_expr THEN ret_statements
    (39) bool_expr -> . bool_term AND bool_term
    (40) bool_expr -> . bool_term OR bool_term
    (41) bool_expr -> . bool_term
    (42) bool_term -> . NOT bool
    (43) bool_term -> . bool
    (44) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (45) bool -> . BOOL_VAL
    (46) bool -> . IDENT
    (47) bool -> . rel_operand rel_operator rel_operand
    (48) rel_operand -> . NUMBER
    (49) rel_operand -> . IDENT

    NOT             shift and go to state 71
    LEFT_PAR        shift and go to state 73
    BOOL_VAL        shift and go to state 74
    IDENT           shift and go to state 75
    NUMBER          shift and go to state 77

    bool_expr                      shift and go to state 154
    bool_term                      shift and go to state 70
    bool                           shift and go to state 72
    rel_operand                    shift and go to state 76

state 150

    (76) for_range -> FOR IDENT IN expr DUB_DOT expr .
    (30) expr -> expr . PLUS term
    (31) expr -> expr . MINUS term

    LOOP            reduce using rule 76 (for_range -> FOR IDENT IN expr DUB_DOT expr .)
    PLUS            shift and go to state 113
    MINUS           shift and go to state 114


state 151

    (12) function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .

    $end            reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)
    BEGIN           reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)
    IDENT           reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)
    FUNC            reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)
    PROC            reduce using rule 12 (function -> FUNC IDENT args_opt RETURN type IS declarations BEGIN ret_statements END IDENT SEMICOLON .)


state 152

    (66) if -> IF bool_expr THEN ret_statements elsifs else END . IF SEMICOLON

    IF              shift and go to state 155


state 153

    (70) else -> ELSE ret_statements .
    (61) ret_statements -> ret_statements . ret_statement
    (63) ret_statement -> . statement
    (64) ret_statement -> . RETURN value SEMICOLON
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    END             reduce using rule 70 (else -> ELSE ret_statements .)
    RETURN          shift and go to state 108
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    ret_statement                  shift and go to state 133
    statement                      shift and go to state 111
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 154

    (69) elsif -> ELSIF bool_expr . THEN ret_statements

    THEN            shift and go to state 156


state 155

    (66) if -> IF bool_expr THEN ret_statements elsifs else END IF . SEMICOLON

    SEMICOLON       shift and go to state 157


state 156

    (69) elsif -> ELSIF bool_expr THEN . ret_statements
    (61) ret_statements -> . ret_statements ret_statement
    (62) ret_statements -> . ret_statement
    (63) ret_statement -> . statement
    (64) ret_statement -> . RETURN value SEMICOLON
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    RETURN          shift and go to state 108
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    ret_statements                 shift and go to state 158
    ret_statement                  shift and go to state 110
    statement                      shift and go to state 111
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60

state 157

    (66) if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .

    END             reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    IDENT           reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    IF              reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    LOOP            reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    FOR             reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    WHILE           reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    RETURN          reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    ELSE            reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)
    ELSIF           reduce using rule 66 (if -> IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON .)


state 158

    (69) elsif -> ELSIF bool_expr THEN ret_statements .
    (61) ret_statements -> ret_statements . ret_statement
    (63) ret_statement -> . statement
    (64) ret_statement -> . RETURN value SEMICOLON
    (58) statement -> . assign
    (59) statement -> . if
    (60) statement -> . loop
    (65) assign -> . IDENT ASSIGN value SEMICOLON
    (66) if -> . IF bool_expr THEN ret_statements elsifs else END IF SEMICOLON
    (72) loop -> . loop_body
    (73) loop -> . for_range loop_body
    (74) loop -> . while loop_body
    (75) loop_body -> . LOOP statements END LOOP SEMICOLON
    (76) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (77) while -> . WHILE bool_expr

    ELSE            reduce using rule 69 (elsif -> ELSIF bool_expr THEN ret_statements .)
    ELSIF           reduce using rule 69 (elsif -> ELSIF bool_expr THEN ret_statements .)
    END             reduce using rule 69 (elsif -> ELSIF bool_expr THEN ret_statements .)
    RETURN          shift and go to state 108
    IDENT           shift and go to state 51
    IF              shift and go to state 57
    LOOP            shift and go to state 61
    FOR             shift and go to state 62
    WHILE           shift and go to state 63

    ret_statement                  shift and go to state 133
    statement                      shift and go to state 111
    assign                         shift and go to state 54
    if                             shift and go to state 55
    loop                           shift and go to state 56
    loop_body                      shift and go to state 58
    for_range                      shift and go to state 59
    while                          shift and go to state 60
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENT in state 22 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 22 resolved as shift
WARNING: shift/reduce conflict for PROC in state 22 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 30 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 30 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 30 resolved as shift
WARNING: shift/reduce conflict for PROC in state 30 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 48 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 48 resolved as shift
WARNING: shift/reduce conflict for PROC in state 48 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 64 resolved as shift
WARNING: shift/reduce conflict for IDENT in state 64 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 64 resolved as shift
WARNING: shift/reduce conflict for PROC in state 64 resolved as shift
WARNING: reduce/reduce conflict in state 84 resolved using rule (factor -> IDENT)
WARNING: rejected rule (bool -> IDENT) in state 84
