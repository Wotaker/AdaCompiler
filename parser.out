Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABS
    AMPERSAND
    APOSTROPHE
    ARRAY
    BOOL
    COMMENT
    DECLARE
    EQUALS
    FUNC
    GREATER
    GTEQ
    LEFT_CUR_PAR
    LEFT_SQ_PAR
    LESS
    LSEQ
    MOD
    NOT_EQUALS
    NULL
    OF
    POW
    QUOTE
    RETURN
    REVERSE
    RIGHT_CUR_PAR
    RIGHT_SQ_PAR
    TYPE
    XOR

Grammar

Rule 0     S' -> prog
Rule 1     empty -> <empty>
Rule 2     prog -> subprogram
Rule 3     prog -> headers subprogram
Rule 4     headers -> headers header
Rule 5     headers -> header
Rule 6     header -> WITH pkg SEMICOLON
Rule 7     header -> WITH pkg SEMICOLON USE pkg SEMICOLON
Rule 8     pkg -> pkg DOT IDENT
Rule 9     pkg -> IDENT
Rule 10    subprogram -> procedure
Rule 11    subprogram -> function
Rule 12    function -> IDENT
Rule 13    procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
Rule 14    args_opt -> LEFT_PAR args RIGHT_PAR
Rule 15    args_opt -> empty
Rule 16    args -> args COMMA arg
Rule 17    args -> arg
Rule 18    arg -> IDENT COLON type
Rule 19    type -> TYPE_INT
Rule 20    type -> TYPE_FLOAT
Rule 21    type -> TYPE_BOOL
Rule 22    declarations -> declarations declaration
Rule 23    declarations -> declaration
Rule 24    declaration -> IDENT COLON type ASSIGN value SEMICOLON
Rule 25    value -> expr
Rule 26    value -> bool_expr
Rule 27    expr -> expr PLUS term
Rule 28    expr -> expr MINUS term
Rule 29    expr -> term
Rule 30    term -> term MUL factor
Rule 31    term -> term DIV factor
Rule 32    term -> factor
Rule 33    factor -> LEFT_PAR expr RIGHT_PAR
Rule 34    factor -> IDENT
Rule 35    factor -> NUMBER
Rule 36    bool_expr -> bool_term AND bool_term
Rule 37    bool_expr -> bool_term OR bool_term
Rule 38    bool_expr -> bool_term
Rule 39    bool_term -> NOT bool
Rule 40    bool_term -> bool
Rule 41    bool -> LEFT_PAR bool_expr RIGHT_PAR
Rule 42    bool -> BOOL_VAL
Rule 43    bool -> IDENT
Rule 44    statements -> statements statement
Rule 45    statements -> statement
Rule 46    statement -> assign
Rule 47    statement -> if
Rule 48    statement -> loop
Rule 49    assign -> IDENT ASSIGN value SEMICOLON
Rule 50    if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON
Rule 51    elsifs -> elsifs elsif
Rule 52    elsifs -> empty
Rule 53    elsif -> ELSIF bool_expr THEN statements
Rule 54    else -> ELSE statements
Rule 55    else -> empty
Rule 56    loop -> loop_body
Rule 57    loop -> for_range loop_body
Rule 58    loop -> while loop_body
Rule 59    loop_body -> LOOP statements END LOOP SEMICOLON
Rule 60    for_range -> FOR IDENT IN expr DUB_DOT expr
Rule 61    while -> WHILE bool_expr

Terminals, with rules where they appear

ABS                  : 
AMPERSAND            : 
AND                  : 36
APOSTROPHE           : 
ARRAY                : 
ASSIGN               : 24 49
BEGIN                : 13
BOOL                 : 
BOOL_VAL             : 42
COLON                : 18 24
COMMA                : 16
COMMENT              : 
DECLARE              : 
DIV                  : 31
DOT                  : 8
DUB_DOT              : 60
ELSE                 : 54
ELSIF                : 53
END                  : 13 50 59
EQUALS               : 
FOR                  : 60
FUNC                 : 
GREATER              : 
GTEQ                 : 
IDENT                : 8 9 12 13 13 18 24 34 43 49 60
IF                   : 50 50
IN                   : 60
IS                   : 13
LEFT_CUR_PAR         : 
LEFT_PAR             : 14 33 41
LEFT_SQ_PAR          : 
LESS                 : 
LOOP                 : 59 59
LSEQ                 : 
MINUS                : 28
MOD                  : 
MUL                  : 30
NOT                  : 39
NOT_EQUALS           : 
NULL                 : 
NUMBER               : 35
OF                   : 
OR                   : 37
PLUS                 : 27
POW                  : 
PROC                 : 13
QUOTE                : 
RETURN               : 
REVERSE              : 
RIGHT_CUR_PAR        : 
RIGHT_PAR            : 14 33 41
RIGHT_SQ_PAR         : 
SEMICOLON            : 6 7 7 13 24 49 50 59
THEN                 : 50 53
TYPE                 : 
TYPE_BOOL            : 21
TYPE_FLOAT           : 20
TYPE_INT             : 19
USE                  : 7
WHILE                : 61
WITH                 : 6 7
XOR                  : 
error                : 

Nonterminals, with rules where they appear

arg                  : 16 17
args                 : 14 16
args_opt             : 13
assign               : 46
bool                 : 39 40
bool_expr            : 26 41 50 53 61
bool_term            : 36 36 37 37 38
declaration          : 22 23
declarations         : 13 22
else                 : 50
elsif                : 51
elsifs               : 50 51
empty                : 15 52 55
expr                 : 25 27 28 33 60 60
factor               : 30 31 32
for_range            : 57
function             : 11
header               : 4 5
headers              : 3 4
if                   : 47
loop                 : 48
loop_body            : 56 57 58
pkg                  : 6 7 7 8
procedure            : 10
prog                 : 0
statement            : 44 45
statements           : 13 44 50 53 54 59
subprogram           : 2 3
term                 : 27 28 29 30 31
type                 : 18 24
value                : 24 49
while                : 58

Parsing method: LALR

state 0

    (0) S' -> . prog
    (2) prog -> . subprogram
    (3) prog -> . headers subprogram
    (10) subprogram -> . procedure
    (11) subprogram -> . function
    (4) headers -> . headers header
    (5) headers -> . header
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (12) function -> . IDENT
    (6) header -> . WITH pkg SEMICOLON
    (7) header -> . WITH pkg SEMICOLON USE pkg SEMICOLON

    PROC            shift and go to state 7
    IDENT           shift and go to state 8
    WITH            shift and go to state 9

    prog                           shift and go to state 1
    subprogram                     shift and go to state 2
    headers                        shift and go to state 3
    procedure                      shift and go to state 4
    function                       shift and go to state 5
    header                         shift and go to state 6

state 1

    (0) S' -> prog .



state 2

    (2) prog -> subprogram .

    $end            reduce using rule 2 (prog -> subprogram .)


state 3

    (3) prog -> headers . subprogram
    (4) headers -> headers . header
    (10) subprogram -> . procedure
    (11) subprogram -> . function
    (6) header -> . WITH pkg SEMICOLON
    (7) header -> . WITH pkg SEMICOLON USE pkg SEMICOLON
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (12) function -> . IDENT

    WITH            shift and go to state 9
    PROC            shift and go to state 7
    IDENT           shift and go to state 8

    subprogram                     shift and go to state 10
    header                         shift and go to state 11
    procedure                      shift and go to state 4
    function                       shift and go to state 5

state 4

    (10) subprogram -> procedure .

    $end            reduce using rule 10 (subprogram -> procedure .)


state 5

    (11) subprogram -> function .

    $end            reduce using rule 11 (subprogram -> function .)


state 6

    (5) headers -> header .

    WITH            reduce using rule 5 (headers -> header .)
    PROC            reduce using rule 5 (headers -> header .)
    IDENT           reduce using rule 5 (headers -> header .)


state 7

    (13) procedure -> PROC . IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

    IDENT           shift and go to state 12


state 8

    (12) function -> IDENT .

    $end            reduce using rule 12 (function -> IDENT .)


state 9

    (6) header -> WITH . pkg SEMICOLON
    (7) header -> WITH . pkg SEMICOLON USE pkg SEMICOLON
    (8) pkg -> . pkg DOT IDENT
    (9) pkg -> . IDENT

    IDENT           shift and go to state 14

    pkg                            shift and go to state 13

state 10

    (3) prog -> headers subprogram .

    $end            reduce using rule 3 (prog -> headers subprogram .)


state 11

    (4) headers -> headers header .

    WITH            reduce using rule 4 (headers -> headers header .)
    PROC            reduce using rule 4 (headers -> headers header .)
    IDENT           reduce using rule 4 (headers -> headers header .)


state 12

    (13) procedure -> PROC IDENT . args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (14) args_opt -> . LEFT_PAR args RIGHT_PAR
    (15) args_opt -> . empty
    (1) empty -> .

    LEFT_PAR        shift and go to state 16
    IS              reduce using rule 1 (empty -> .)

    args_opt                       shift and go to state 15
    empty                          shift and go to state 17

state 13

    (6) header -> WITH pkg . SEMICOLON
    (7) header -> WITH pkg . SEMICOLON USE pkg SEMICOLON
    (8) pkg -> pkg . DOT IDENT

    SEMICOLON       shift and go to state 18
    DOT             shift and go to state 19


state 14

    (9) pkg -> IDENT .

    SEMICOLON       reduce using rule 9 (pkg -> IDENT .)
    DOT             reduce using rule 9 (pkg -> IDENT .)


state 15

    (13) procedure -> PROC IDENT args_opt . IS declarations BEGIN statements END IDENT SEMICOLON

    IS              shift and go to state 20


state 16

    (14) args_opt -> LEFT_PAR . args RIGHT_PAR
    (16) args -> . args COMMA arg
    (17) args -> . arg
    (18) arg -> . IDENT COLON type

    IDENT           shift and go to state 23

    args                           shift and go to state 21
    arg                            shift and go to state 22

state 17

    (15) args_opt -> empty .

    IS              reduce using rule 15 (args_opt -> empty .)


state 18

    (6) header -> WITH pkg SEMICOLON .
    (7) header -> WITH pkg SEMICOLON . USE pkg SEMICOLON

    WITH            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    PROC            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    IDENT           reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    USE             shift and go to state 24


state 19

    (8) pkg -> pkg DOT . IDENT

    IDENT           shift and go to state 25


state 20

    (13) procedure -> PROC IDENT args_opt IS . declarations BEGIN statements END IDENT SEMICOLON
    (22) declarations -> . declarations declaration
    (23) declarations -> . declaration
    (24) declaration -> . IDENT COLON type ASSIGN value SEMICOLON

    IDENT           shift and go to state 26

    declarations                   shift and go to state 27
    declaration                    shift and go to state 28

state 21

    (14) args_opt -> LEFT_PAR args . RIGHT_PAR
    (16) args -> args . COMMA arg

    RIGHT_PAR       shift and go to state 29
    COMMA           shift and go to state 30


state 22

    (17) args -> arg .

    RIGHT_PAR       reduce using rule 17 (args -> arg .)
    COMMA           reduce using rule 17 (args -> arg .)


state 23

    (18) arg -> IDENT . COLON type

    COLON           shift and go to state 31


state 24

    (7) header -> WITH pkg SEMICOLON USE . pkg SEMICOLON
    (8) pkg -> . pkg DOT IDENT
    (9) pkg -> . IDENT

    IDENT           shift and go to state 14

    pkg                            shift and go to state 32

state 25

    (8) pkg -> pkg DOT IDENT .

    SEMICOLON       reduce using rule 8 (pkg -> pkg DOT IDENT .)
    DOT             reduce using rule 8 (pkg -> pkg DOT IDENT .)


state 26

    (24) declaration -> IDENT . COLON type ASSIGN value SEMICOLON

    COLON           shift and go to state 33


state 27

    (13) procedure -> PROC IDENT args_opt IS declarations . BEGIN statements END IDENT SEMICOLON
    (22) declarations -> declarations . declaration
    (24) declaration -> . IDENT COLON type ASSIGN value SEMICOLON

    BEGIN           shift and go to state 34
    IDENT           shift and go to state 26

    declaration                    shift and go to state 35

state 28

    (23) declarations -> declaration .

    BEGIN           reduce using rule 23 (declarations -> declaration .)
    IDENT           reduce using rule 23 (declarations -> declaration .)


state 29

    (14) args_opt -> LEFT_PAR args RIGHT_PAR .

    IS              reduce using rule 14 (args_opt -> LEFT_PAR args RIGHT_PAR .)


state 30

    (16) args -> args COMMA . arg
    (18) arg -> . IDENT COLON type

    IDENT           shift and go to state 23

    arg                            shift and go to state 36

state 31

    (18) arg -> IDENT COLON . type
    (19) type -> . TYPE_INT
    (20) type -> . TYPE_FLOAT
    (21) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_BOOL       shift and go to state 40

    type                           shift and go to state 37

state 32

    (7) header -> WITH pkg SEMICOLON USE pkg . SEMICOLON
    (8) pkg -> pkg . DOT IDENT

    SEMICOLON       shift and go to state 41
    DOT             shift and go to state 19


state 33

    (24) declaration -> IDENT COLON . type ASSIGN value SEMICOLON
    (19) type -> . TYPE_INT
    (20) type -> . TYPE_FLOAT
    (21) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_BOOL       shift and go to state 40

    type                           shift and go to state 42

state 34

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN . statements END IDENT SEMICOLON
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statements                     shift and go to state 44
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 35

    (22) declarations -> declarations declaration .

    BEGIN           reduce using rule 22 (declarations -> declarations declaration .)
    IDENT           reduce using rule 22 (declarations -> declarations declaration .)


state 36

    (16) args -> args COMMA arg .

    RIGHT_PAR       reduce using rule 16 (args -> args COMMA arg .)
    COMMA           reduce using rule 16 (args -> args COMMA arg .)


state 37

    (18) arg -> IDENT COLON type .

    RIGHT_PAR       reduce using rule 18 (arg -> IDENT COLON type .)
    COMMA           reduce using rule 18 (arg -> IDENT COLON type .)


state 38

    (19) type -> TYPE_INT .

    RIGHT_PAR       reduce using rule 19 (type -> TYPE_INT .)
    COMMA           reduce using rule 19 (type -> TYPE_INT .)
    ASSIGN          reduce using rule 19 (type -> TYPE_INT .)


state 39

    (20) type -> TYPE_FLOAT .

    RIGHT_PAR       reduce using rule 20 (type -> TYPE_FLOAT .)
    COMMA           reduce using rule 20 (type -> TYPE_FLOAT .)
    ASSIGN          reduce using rule 20 (type -> TYPE_FLOAT .)


state 40

    (21) type -> TYPE_BOOL .

    RIGHT_PAR       reduce using rule 21 (type -> TYPE_BOOL .)
    COMMA           reduce using rule 21 (type -> TYPE_BOOL .)
    ASSIGN          reduce using rule 21 (type -> TYPE_BOOL .)


state 41

    (7) header -> WITH pkg SEMICOLON USE pkg SEMICOLON .

    WITH            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)
    PROC            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)
    IDENT           reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)


state 42

    (24) declaration -> IDENT COLON type . ASSIGN value SEMICOLON

    ASSIGN          shift and go to state 56


state 43

    (49) assign -> IDENT . ASSIGN value SEMICOLON

    ASSIGN          shift and go to state 57


state 44

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements . END IDENT SEMICOLON
    (44) statements -> statements . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    END             shift and go to state 58
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statement                      shift and go to state 59
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 45

    (45) statements -> statement .

    END             reduce using rule 45 (statements -> statement .)
    IDENT           reduce using rule 45 (statements -> statement .)
    IF              reduce using rule 45 (statements -> statement .)
    LOOP            reduce using rule 45 (statements -> statement .)
    FOR             reduce using rule 45 (statements -> statement .)
    WHILE           reduce using rule 45 (statements -> statement .)
    ELSE            reduce using rule 45 (statements -> statement .)
    ELSIF           reduce using rule 45 (statements -> statement .)


state 46

    (46) statement -> assign .

    END             reduce using rule 46 (statement -> assign .)
    IDENT           reduce using rule 46 (statement -> assign .)
    IF              reduce using rule 46 (statement -> assign .)
    LOOP            reduce using rule 46 (statement -> assign .)
    FOR             reduce using rule 46 (statement -> assign .)
    WHILE           reduce using rule 46 (statement -> assign .)
    ELSE            reduce using rule 46 (statement -> assign .)
    ELSIF           reduce using rule 46 (statement -> assign .)


state 47

    (47) statement -> if .

    END             reduce using rule 47 (statement -> if .)
    IDENT           reduce using rule 47 (statement -> if .)
    IF              reduce using rule 47 (statement -> if .)
    LOOP            reduce using rule 47 (statement -> if .)
    FOR             reduce using rule 47 (statement -> if .)
    WHILE           reduce using rule 47 (statement -> if .)
    ELSE            reduce using rule 47 (statement -> if .)
    ELSIF           reduce using rule 47 (statement -> if .)


state 48

    (48) statement -> loop .

    END             reduce using rule 48 (statement -> loop .)
    IDENT           reduce using rule 48 (statement -> loop .)
    IF              reduce using rule 48 (statement -> loop .)
    LOOP            reduce using rule 48 (statement -> loop .)
    FOR             reduce using rule 48 (statement -> loop .)
    WHILE           reduce using rule 48 (statement -> loop .)
    ELSE            reduce using rule 48 (statement -> loop .)
    ELSIF           reduce using rule 48 (statement -> loop .)


state 49

    (50) if -> IF . bool_expr THEN statements elsifs else END IF SEMICOLON
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 64
    BOOL_VAL        shift and go to state 65
    IDENT           shift and go to state 66

    bool_expr                      shift and go to state 60
    bool_term                      shift and go to state 61
    bool                           shift and go to state 63

state 50

    (56) loop -> loop_body .

    END             reduce using rule 56 (loop -> loop_body .)
    IDENT           reduce using rule 56 (loop -> loop_body .)
    IF              reduce using rule 56 (loop -> loop_body .)
    LOOP            reduce using rule 56 (loop -> loop_body .)
    FOR             reduce using rule 56 (loop -> loop_body .)
    WHILE           reduce using rule 56 (loop -> loop_body .)
    ELSE            reduce using rule 56 (loop -> loop_body .)
    ELSIF           reduce using rule 56 (loop -> loop_body .)


state 51

    (57) loop -> for_range . loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON

    LOOP            shift and go to state 53

    loop_body                      shift and go to state 67

state 52

    (58) loop -> while . loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON

    LOOP            shift and go to state 53

    loop_body                      shift and go to state 68

state 53

    (59) loop_body -> LOOP . statements END LOOP SEMICOLON
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statements                     shift and go to state 69
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 54

    (60) for_range -> FOR . IDENT IN expr DUB_DOT expr

    IDENT           shift and go to state 70


state 55

    (61) while -> WHILE . bool_expr
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 64
    BOOL_VAL        shift and go to state 65
    IDENT           shift and go to state 66

    bool_expr                      shift and go to state 71
    bool_term                      shift and go to state 61
    bool                           shift and go to state 63

state 56

    (24) declaration -> IDENT COLON type ASSIGN . value SEMICOLON
    (25) value -> . expr
    (26) value -> . bool_expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 78
    IDENT           shift and go to state 72
    NUMBER          shift and go to state 79
    BOOL_VAL        shift and go to state 65

    value                          shift and go to state 73
    expr                           shift and go to state 74
    bool_expr                      shift and go to state 75
    term                           shift and go to state 76
    bool_term                      shift and go to state 61
    factor                         shift and go to state 77
    bool                           shift and go to state 63

state 57

    (49) assign -> IDENT ASSIGN . value SEMICOLON
    (25) value -> . expr
    (26) value -> . bool_expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 78
    IDENT           shift and go to state 72
    NUMBER          shift and go to state 79
    BOOL_VAL        shift and go to state 65

    value                          shift and go to state 80
    expr                           shift and go to state 74
    bool_expr                      shift and go to state 75
    term                           shift and go to state 76
    bool_term                      shift and go to state 61
    factor                         shift and go to state 77
    bool                           shift and go to state 63

state 58

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END . IDENT SEMICOLON

    IDENT           shift and go to state 81


state 59

    (44) statements -> statements statement .

    END             reduce using rule 44 (statements -> statements statement .)
    IDENT           reduce using rule 44 (statements -> statements statement .)
    IF              reduce using rule 44 (statements -> statements statement .)
    LOOP            reduce using rule 44 (statements -> statements statement .)
    FOR             reduce using rule 44 (statements -> statements statement .)
    WHILE           reduce using rule 44 (statements -> statements statement .)
    ELSE            reduce using rule 44 (statements -> statements statement .)
    ELSIF           reduce using rule 44 (statements -> statements statement .)


state 60

    (50) if -> IF bool_expr . THEN statements elsifs else END IF SEMICOLON

    THEN            shift and go to state 82


state 61

    (36) bool_expr -> bool_term . AND bool_term
    (37) bool_expr -> bool_term . OR bool_term
    (38) bool_expr -> bool_term .

    AND             shift and go to state 83
    OR              shift and go to state 84
    THEN            reduce using rule 38 (bool_expr -> bool_term .)
    LOOP            reduce using rule 38 (bool_expr -> bool_term .)
    SEMICOLON       reduce using rule 38 (bool_expr -> bool_term .)
    RIGHT_PAR       reduce using rule 38 (bool_expr -> bool_term .)


state 62

    (39) bool_term -> NOT . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    LEFT_PAR        shift and go to state 64
    BOOL_VAL        shift and go to state 65
    IDENT           shift and go to state 66

    bool                           shift and go to state 85

state 63

    (40) bool_term -> bool .

    AND             reduce using rule 40 (bool_term -> bool .)
    OR              reduce using rule 40 (bool_term -> bool .)
    THEN            reduce using rule 40 (bool_term -> bool .)
    LOOP            reduce using rule 40 (bool_term -> bool .)
    SEMICOLON       reduce using rule 40 (bool_term -> bool .)
    RIGHT_PAR       reduce using rule 40 (bool_term -> bool .)


state 64

    (41) bool -> LEFT_PAR . bool_expr RIGHT_PAR
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 64
    BOOL_VAL        shift and go to state 65
    IDENT           shift and go to state 66

    bool_expr                      shift and go to state 86
    bool_term                      shift and go to state 61
    bool                           shift and go to state 63

state 65

    (42) bool -> BOOL_VAL .

    AND             reduce using rule 42 (bool -> BOOL_VAL .)
    OR              reduce using rule 42 (bool -> BOOL_VAL .)
    THEN            reduce using rule 42 (bool -> BOOL_VAL .)
    LOOP            reduce using rule 42 (bool -> BOOL_VAL .)
    SEMICOLON       reduce using rule 42 (bool -> BOOL_VAL .)
    RIGHT_PAR       reduce using rule 42 (bool -> BOOL_VAL .)


state 66

    (43) bool -> IDENT .

    AND             reduce using rule 43 (bool -> IDENT .)
    OR              reduce using rule 43 (bool -> IDENT .)
    THEN            reduce using rule 43 (bool -> IDENT .)
    LOOP            reduce using rule 43 (bool -> IDENT .)
    SEMICOLON       reduce using rule 43 (bool -> IDENT .)
    RIGHT_PAR       reduce using rule 43 (bool -> IDENT .)


state 67

    (57) loop -> for_range loop_body .

    END             reduce using rule 57 (loop -> for_range loop_body .)
    IDENT           reduce using rule 57 (loop -> for_range loop_body .)
    IF              reduce using rule 57 (loop -> for_range loop_body .)
    LOOP            reduce using rule 57 (loop -> for_range loop_body .)
    FOR             reduce using rule 57 (loop -> for_range loop_body .)
    WHILE           reduce using rule 57 (loop -> for_range loop_body .)
    ELSE            reduce using rule 57 (loop -> for_range loop_body .)
    ELSIF           reduce using rule 57 (loop -> for_range loop_body .)


state 68

    (58) loop -> while loop_body .

    END             reduce using rule 58 (loop -> while loop_body .)
    IDENT           reduce using rule 58 (loop -> while loop_body .)
    IF              reduce using rule 58 (loop -> while loop_body .)
    LOOP            reduce using rule 58 (loop -> while loop_body .)
    FOR             reduce using rule 58 (loop -> while loop_body .)
    WHILE           reduce using rule 58 (loop -> while loop_body .)
    ELSE            reduce using rule 58 (loop -> while loop_body .)
    ELSIF           reduce using rule 58 (loop -> while loop_body .)


state 69

    (59) loop_body -> LOOP statements . END LOOP SEMICOLON
    (44) statements -> statements . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    END             shift and go to state 87
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statement                      shift and go to state 59
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 70

    (60) for_range -> FOR IDENT . IN expr DUB_DOT expr

    IN              shift and go to state 88


state 71

    (61) while -> WHILE bool_expr .

    LOOP            reduce using rule 61 (while -> WHILE bool_expr .)


state 72

    (34) factor -> IDENT .
    (43) bool -> IDENT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 34 (factor -> IDENT .)
  ! reduce/reduce conflict for RIGHT_PAR resolved using rule 34 (factor -> IDENT .)
    MUL             reduce using rule 34 (factor -> IDENT .)
    DIV             reduce using rule 34 (factor -> IDENT .)
    PLUS            reduce using rule 34 (factor -> IDENT .)
    MINUS           reduce using rule 34 (factor -> IDENT .)
    SEMICOLON       reduce using rule 34 (factor -> IDENT .)
    RIGHT_PAR       reduce using rule 34 (factor -> IDENT .)
    AND             reduce using rule 43 (bool -> IDENT .)
    OR              reduce using rule 43 (bool -> IDENT .)

  ! SEMICOLON       [ reduce using rule 43 (bool -> IDENT .) ]
  ! RIGHT_PAR       [ reduce using rule 43 (bool -> IDENT .) ]


state 73

    (24) declaration -> IDENT COLON type ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 89


state 74

    (25) value -> expr .
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    SEMICOLON       reduce using rule 25 (value -> expr .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91


state 75

    (26) value -> bool_expr .

    SEMICOLON       reduce using rule 26 (value -> bool_expr .)


state 76

    (29) expr -> term .
    (30) term -> term . MUL factor
    (31) term -> term . DIV factor

    PLUS            reduce using rule 29 (expr -> term .)
    MINUS           reduce using rule 29 (expr -> term .)
    SEMICOLON       reduce using rule 29 (expr -> term .)
    RIGHT_PAR       reduce using rule 29 (expr -> term .)
    DUB_DOT         reduce using rule 29 (expr -> term .)
    LOOP            reduce using rule 29 (expr -> term .)
    MUL             shift and go to state 92
    DIV             shift and go to state 93


state 77

    (32) term -> factor .

    MUL             reduce using rule 32 (term -> factor .)
    DIV             reduce using rule 32 (term -> factor .)
    PLUS            reduce using rule 32 (term -> factor .)
    MINUS           reduce using rule 32 (term -> factor .)
    SEMICOLON       reduce using rule 32 (term -> factor .)
    RIGHT_PAR       reduce using rule 32 (term -> factor .)
    DUB_DOT         reduce using rule 32 (term -> factor .)
    LOOP            reduce using rule 32 (term -> factor .)


state 78

    (33) factor -> LEFT_PAR . expr RIGHT_PAR
    (41) bool -> LEFT_PAR . bool_expr RIGHT_PAR
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 78
    IDENT           shift and go to state 72
    NUMBER          shift and go to state 79
    BOOL_VAL        shift and go to state 65

    expr                           shift and go to state 94
    bool_expr                      shift and go to state 86
    term                           shift and go to state 76
    bool_term                      shift and go to state 61
    factor                         shift and go to state 77
    bool                           shift and go to state 63

state 79

    (35) factor -> NUMBER .

    MUL             reduce using rule 35 (factor -> NUMBER .)
    DIV             reduce using rule 35 (factor -> NUMBER .)
    PLUS            reduce using rule 35 (factor -> NUMBER .)
    MINUS           reduce using rule 35 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 35 (factor -> NUMBER .)
    RIGHT_PAR       reduce using rule 35 (factor -> NUMBER .)
    DUB_DOT         reduce using rule 35 (factor -> NUMBER .)
    LOOP            reduce using rule 35 (factor -> NUMBER .)


state 80

    (49) assign -> IDENT ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 95


state 81

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT . SEMICOLON

    SEMICOLON       shift and go to state 96


state 82

    (50) if -> IF bool_expr THEN . statements elsifs else END IF SEMICOLON
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statements                     shift and go to state 97
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 83

    (36) bool_expr -> bool_term AND . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 64
    BOOL_VAL        shift and go to state 65
    IDENT           shift and go to state 66

    bool_term                      shift and go to state 98
    bool                           shift and go to state 63

state 84

    (37) bool_expr -> bool_term OR . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 64
    BOOL_VAL        shift and go to state 65
    IDENT           shift and go to state 66

    bool_term                      shift and go to state 99
    bool                           shift and go to state 63

state 85

    (39) bool_term -> NOT bool .

    AND             reduce using rule 39 (bool_term -> NOT bool .)
    OR              reduce using rule 39 (bool_term -> NOT bool .)
    THEN            reduce using rule 39 (bool_term -> NOT bool .)
    LOOP            reduce using rule 39 (bool_term -> NOT bool .)
    SEMICOLON       reduce using rule 39 (bool_term -> NOT bool .)
    RIGHT_PAR       reduce using rule 39 (bool_term -> NOT bool .)


state 86

    (41) bool -> LEFT_PAR bool_expr . RIGHT_PAR

    RIGHT_PAR       shift and go to state 100


state 87

    (59) loop_body -> LOOP statements END . LOOP SEMICOLON

    LOOP            shift and go to state 101


state 88

    (60) for_range -> FOR IDENT IN . expr DUB_DOT expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 104
    IDENT           shift and go to state 102
    NUMBER          shift and go to state 79

    expr                           shift and go to state 103
    term                           shift and go to state 76
    factor                         shift and go to state 77

state 89

    (24) declaration -> IDENT COLON type ASSIGN value SEMICOLON .

    BEGIN           reduce using rule 24 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)
    IDENT           reduce using rule 24 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)


state 90

    (27) expr -> expr PLUS . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 104
    IDENT           shift and go to state 102
    NUMBER          shift and go to state 79

    term                           shift and go to state 105
    factor                         shift and go to state 77

state 91

    (28) expr -> expr MINUS . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 104
    IDENT           shift and go to state 102
    NUMBER          shift and go to state 79

    term                           shift and go to state 106
    factor                         shift and go to state 77

state 92

    (30) term -> term MUL . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 104
    IDENT           shift and go to state 102
    NUMBER          shift and go to state 79

    factor                         shift and go to state 107

state 93

    (31) term -> term DIV . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 104
    IDENT           shift and go to state 102
    NUMBER          shift and go to state 79

    factor                         shift and go to state 108

state 94

    (33) factor -> LEFT_PAR expr . RIGHT_PAR
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    RIGHT_PAR       shift and go to state 109
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91


state 95

    (49) assign -> IDENT ASSIGN value SEMICOLON .

    END             reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    IDENT           reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    IF              reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    LOOP            reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    FOR             reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    WHILE           reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    ELSE            reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    ELSIF           reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)


state 96

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .

    $end            reduce using rule 13 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)


state 97

    (50) if -> IF bool_expr THEN statements . elsifs else END IF SEMICOLON
    (44) statements -> statements . statement
    (51) elsifs -> . elsifs elsif
    (52) elsifs -> . empty
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (1) empty -> .
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    ELSE            reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    elsifs                         shift and go to state 110
    statement                      shift and go to state 59
    empty                          shift and go to state 111
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 98

    (36) bool_expr -> bool_term AND bool_term .

    THEN            reduce using rule 36 (bool_expr -> bool_term AND bool_term .)
    LOOP            reduce using rule 36 (bool_expr -> bool_term AND bool_term .)
    SEMICOLON       reduce using rule 36 (bool_expr -> bool_term AND bool_term .)
    RIGHT_PAR       reduce using rule 36 (bool_expr -> bool_term AND bool_term .)


state 99

    (37) bool_expr -> bool_term OR bool_term .

    THEN            reduce using rule 37 (bool_expr -> bool_term OR bool_term .)
    LOOP            reduce using rule 37 (bool_expr -> bool_term OR bool_term .)
    SEMICOLON       reduce using rule 37 (bool_expr -> bool_term OR bool_term .)
    RIGHT_PAR       reduce using rule 37 (bool_expr -> bool_term OR bool_term .)


state 100

    (41) bool -> LEFT_PAR bool_expr RIGHT_PAR .

    AND             reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    OR              reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    THEN            reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    LOOP            reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)


state 101

    (59) loop_body -> LOOP statements END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 112


state 102

    (34) factor -> IDENT .

    MUL             reduce using rule 34 (factor -> IDENT .)
    DIV             reduce using rule 34 (factor -> IDENT .)
    DUB_DOT         reduce using rule 34 (factor -> IDENT .)
    PLUS            reduce using rule 34 (factor -> IDENT .)
    MINUS           reduce using rule 34 (factor -> IDENT .)
    SEMICOLON       reduce using rule 34 (factor -> IDENT .)
    RIGHT_PAR       reduce using rule 34 (factor -> IDENT .)
    LOOP            reduce using rule 34 (factor -> IDENT .)


state 103

    (60) for_range -> FOR IDENT IN expr . DUB_DOT expr
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    DUB_DOT         shift and go to state 113
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91


state 104

    (33) factor -> LEFT_PAR . expr RIGHT_PAR
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 104
    IDENT           shift and go to state 102
    NUMBER          shift and go to state 79

    expr                           shift and go to state 94
    term                           shift and go to state 76
    factor                         shift and go to state 77

state 105

    (27) expr -> expr PLUS term .
    (30) term -> term . MUL factor
    (31) term -> term . DIV factor

    PLUS            reduce using rule 27 (expr -> expr PLUS term .)
    MINUS           reduce using rule 27 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 27 (expr -> expr PLUS term .)
    RIGHT_PAR       reduce using rule 27 (expr -> expr PLUS term .)
    DUB_DOT         reduce using rule 27 (expr -> expr PLUS term .)
    LOOP            reduce using rule 27 (expr -> expr PLUS term .)
    MUL             shift and go to state 92
    DIV             shift and go to state 93


state 106

    (28) expr -> expr MINUS term .
    (30) term -> term . MUL factor
    (31) term -> term . DIV factor

    PLUS            reduce using rule 28 (expr -> expr MINUS term .)
    MINUS           reduce using rule 28 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 28 (expr -> expr MINUS term .)
    RIGHT_PAR       reduce using rule 28 (expr -> expr MINUS term .)
    DUB_DOT         reduce using rule 28 (expr -> expr MINUS term .)
    LOOP            reduce using rule 28 (expr -> expr MINUS term .)
    MUL             shift and go to state 92
    DIV             shift and go to state 93


state 107

    (30) term -> term MUL factor .

    MUL             reduce using rule 30 (term -> term MUL factor .)
    DIV             reduce using rule 30 (term -> term MUL factor .)
    PLUS            reduce using rule 30 (term -> term MUL factor .)
    MINUS           reduce using rule 30 (term -> term MUL factor .)
    SEMICOLON       reduce using rule 30 (term -> term MUL factor .)
    RIGHT_PAR       reduce using rule 30 (term -> term MUL factor .)
    DUB_DOT         reduce using rule 30 (term -> term MUL factor .)
    LOOP            reduce using rule 30 (term -> term MUL factor .)


state 108

    (31) term -> term DIV factor .

    MUL             reduce using rule 31 (term -> term DIV factor .)
    DIV             reduce using rule 31 (term -> term DIV factor .)
    PLUS            reduce using rule 31 (term -> term DIV factor .)
    MINUS           reduce using rule 31 (term -> term DIV factor .)
    SEMICOLON       reduce using rule 31 (term -> term DIV factor .)
    RIGHT_PAR       reduce using rule 31 (term -> term DIV factor .)
    DUB_DOT         reduce using rule 31 (term -> term DIV factor .)
    LOOP            reduce using rule 31 (term -> term DIV factor .)


state 109

    (33) factor -> LEFT_PAR expr RIGHT_PAR .

    MUL             reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    DIV             reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    PLUS            reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    MINUS           reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    DUB_DOT         reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    LOOP            reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)


state 110

    (50) if -> IF bool_expr THEN statements elsifs . else END IF SEMICOLON
    (51) elsifs -> elsifs . elsif
    (54) else -> . ELSE statements
    (55) else -> . empty
    (53) elsif -> . ELSIF bool_expr THEN statements
    (1) empty -> .

    ELSE            shift and go to state 116
    ELSIF           shift and go to state 118
    END             reduce using rule 1 (empty -> .)

    else                           shift and go to state 114
    elsif                          shift and go to state 115
    empty                          shift and go to state 117

state 111

    (52) elsifs -> empty .

    ELSE            reduce using rule 52 (elsifs -> empty .)
    ELSIF           reduce using rule 52 (elsifs -> empty .)
    END             reduce using rule 52 (elsifs -> empty .)


state 112

    (59) loop_body -> LOOP statements END LOOP SEMICOLON .

    END             reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    IDENT           reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    IF              reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    LOOP            reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    FOR             reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    WHILE           reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    ELSE            reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    ELSIF           reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)


state 113

    (60) for_range -> FOR IDENT IN expr DUB_DOT . expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 104
    IDENT           shift and go to state 102
    NUMBER          shift and go to state 79

    expr                           shift and go to state 119
    term                           shift and go to state 76
    factor                         shift and go to state 77

state 114

    (50) if -> IF bool_expr THEN statements elsifs else . END IF SEMICOLON

    END             shift and go to state 120


state 115

    (51) elsifs -> elsifs elsif .

    ELSE            reduce using rule 51 (elsifs -> elsifs elsif .)
    ELSIF           reduce using rule 51 (elsifs -> elsifs elsif .)
    END             reduce using rule 51 (elsifs -> elsifs elsif .)


state 116

    (54) else -> ELSE . statements
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statements                     shift and go to state 121
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 117

    (55) else -> empty .

    END             reduce using rule 55 (else -> empty .)


state 118

    (53) elsif -> ELSIF . bool_expr THEN statements
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 62
    LEFT_PAR        shift and go to state 64
    BOOL_VAL        shift and go to state 65
    IDENT           shift and go to state 66

    bool_expr                      shift and go to state 122
    bool_term                      shift and go to state 61
    bool                           shift and go to state 63

state 119

    (60) for_range -> FOR IDENT IN expr DUB_DOT expr .
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    LOOP            reduce using rule 60 (for_range -> FOR IDENT IN expr DUB_DOT expr .)
    PLUS            shift and go to state 90
    MINUS           shift and go to state 91


state 120

    (50) if -> IF bool_expr THEN statements elsifs else END . IF SEMICOLON

    IF              shift and go to state 123


state 121

    (54) else -> ELSE statements .
    (44) statements -> statements . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    END             reduce using rule 54 (else -> ELSE statements .)
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statement                      shift and go to state 59
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 122

    (53) elsif -> ELSIF bool_expr . THEN statements

    THEN            shift and go to state 124


state 123

    (50) if -> IF bool_expr THEN statements elsifs else END IF . SEMICOLON

    SEMICOLON       shift and go to state 125


state 124

    (53) elsif -> ELSIF bool_expr THEN . statements
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statements                     shift and go to state 126
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52

state 125

    (50) if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .

    END             reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    IDENT           reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    IF              reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    LOOP            reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    FOR             reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    WHILE           reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    ELSE            reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    ELSIF           reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)


state 126

    (53) elsif -> ELSIF bool_expr THEN statements .
    (44) statements -> statements . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . loop_body
    (57) loop -> . for_range loop_body
    (58) loop -> . while loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON
    (60) for_range -> . FOR IDENT IN expr DUB_DOT expr
    (61) while -> . WHILE bool_expr

    ELSE            reduce using rule 53 (elsif -> ELSIF bool_expr THEN statements .)
    ELSIF           reduce using rule 53 (elsif -> ELSIF bool_expr THEN statements .)
    END             reduce using rule 53 (elsif -> ELSIF bool_expr THEN statements .)
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    LOOP            shift and go to state 53
    FOR             shift and go to state 54
    WHILE           shift and go to state 55

    statement                      shift and go to state 59
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
    loop_body                      shift and go to state 50
    for_range                      shift and go to state 51
    while                          shift and go to state 52
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 72 resolved using rule (factor -> IDENT)
WARNING: rejected rule (bool -> IDENT) in state 72
