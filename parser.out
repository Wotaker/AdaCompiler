Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABS
    AMPERSAND
    APOSTROPHE
    ARRAY
    BOOL
    COMMENT
    DECLARE
    EQUALS
    FUNC
    GREATER
    GTEQ
    LEFT_CUR_PAR
    LEFT_SQ_PAR
    LESS
    LSEQ
    MOD
    NOT_EQUALS
    NULL
    POW
    QUOTE
    RETURN
    REVERSE
    RIGHT_CUR_PAR
    RIGHT_SQ_PAR
    TYPE
    XOR

Grammar

Rule 0     S' -> prog
Rule 1     empty -> <empty>
Rule 2     prog -> subprogram
Rule 3     prog -> headers subprogram
Rule 4     headers -> headers header
Rule 5     headers -> header
Rule 6     header -> WITH pkg SEMICOLON
Rule 7     header -> WITH pkg SEMICOLON USE pkg SEMICOLON
Rule 8     pkg -> pkg DOT IDENT
Rule 9     pkg -> IDENT
Rule 10    subprogram -> procedure
Rule 11    subprogram -> function
Rule 12    function -> IDENT
Rule 13    procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
Rule 14    args_opt -> LEFT_PAR args RIGHT_PAR
Rule 15    args_opt -> empty
Rule 16    args -> args COMMA arg
Rule 17    args -> arg
Rule 18    arg -> IDENT COLON type
Rule 19    type -> TYPE_INT
Rule 20    type -> TYPE_FLOAT
Rule 21    type -> TYPE_BOOL
Rule 22    declarations -> declarations declaration
Rule 23    declarations -> declaration
Rule 24    declaration -> IDENT COLON type ASSIGN value SEMICOLON
Rule 25    value -> expr
Rule 26    value -> bool_expr
Rule 27    expr -> expr PLUS term
Rule 28    expr -> expr MINUS term
Rule 29    expr -> term
Rule 30    term -> term MUL factor
Rule 31    term -> term DIV factor
Rule 32    term -> factor
Rule 33    factor -> LEFT_PAR expr RIGHT_PAR
Rule 34    factor -> IDENT
Rule 35    factor -> NUMBER
Rule 36    bool_expr -> bool_term AND bool_term
Rule 37    bool_expr -> bool_term OR bool_term
Rule 38    bool_expr -> bool_term
Rule 39    bool_term -> NOT bool
Rule 40    bool_term -> bool
Rule 41    bool -> LEFT_PAR bool_expr RIGHT_PAR
Rule 42    bool -> BOOL_VAL
Rule 43    bool -> IDENT
Rule 44    statements -> statements statement
Rule 45    statements -> statement
Rule 46    statement -> assign
Rule 47    statement -> if
Rule 48    statement -> loop
Rule 49    assign -> IDENT ASSIGN value SEMICOLON
Rule 50    if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON
Rule 51    elsifs -> elsifs elsif
Rule 52    elsifs -> empty
Rule 53    elsif -> ELSIF bool_expr THEN statements
Rule 54    else -> ELSE statements
Rule 55    else -> empty
Rule 56    loop -> WHILE bool_expr loop_body
Rule 57    loop -> FOR IDENT IN expr DUB_DOT expr loop_body
Rule 58    loop -> FOR IDENT OF IDENT loop_body
Rule 59    loop_body -> LOOP statements END LOOP SEMICOLON

Terminals, with rules where they appear

ABS                  : 
AMPERSAND            : 
AND                  : 36
APOSTROPHE           : 
ARRAY                : 
ASSIGN               : 24 49
BEGIN                : 13
BOOL                 : 
BOOL_VAL             : 42
COLON                : 18 24
COMMA                : 16
COMMENT              : 
DECLARE              : 
DIV                  : 31
DOT                  : 8
DUB_DOT              : 57
ELSE                 : 54
ELSIF                : 53
END                  : 13 50 59
EQUALS               : 
FOR                  : 57 58
FUNC                 : 
GREATER              : 
GTEQ                 : 
IDENT                : 8 9 12 13 13 18 24 34 43 49 57 58 58
IF                   : 50 50
IN                   : 57
IS                   : 13
LEFT_CUR_PAR         : 
LEFT_PAR             : 14 33 41
LEFT_SQ_PAR          : 
LESS                 : 
LOOP                 : 59 59
LSEQ                 : 
MINUS                : 28
MOD                  : 
MUL                  : 30
NOT                  : 39
NOT_EQUALS           : 
NULL                 : 
NUMBER               : 35
OF                   : 58
OR                   : 37
PLUS                 : 27
POW                  : 
PROC                 : 13
QUOTE                : 
RETURN               : 
REVERSE              : 
RIGHT_CUR_PAR        : 
RIGHT_PAR            : 14 33 41
RIGHT_SQ_PAR         : 
SEMICOLON            : 6 7 7 13 24 49 50 59
THEN                 : 50 53
TYPE                 : 
TYPE_BOOL            : 21
TYPE_FLOAT           : 20
TYPE_INT             : 19
USE                  : 7
WHILE                : 56
WITH                 : 6 7
XOR                  : 
error                : 

Nonterminals, with rules where they appear

arg                  : 16 17
args                 : 14 16
args_opt             : 13
assign               : 46
bool                 : 39 40
bool_expr            : 26 41 50 53 56
bool_term            : 36 36 37 37 38
declaration          : 22 23
declarations         : 13 22
else                 : 50
elsif                : 51
elsifs               : 50 51
empty                : 15 52 55
expr                 : 25 27 28 33 57 57
factor               : 30 31 32
function             : 11
header               : 4 5
headers              : 3 4
if                   : 47
loop                 : 48
loop_body            : 56 57 58
pkg                  : 6 7 7 8
procedure            : 10
prog                 : 0
statement            : 44 45
statements           : 13 44 50 53 54 59
subprogram           : 2 3
term                 : 27 28 29 30 31
type                 : 18 24
value                : 24 49

Parsing method: LALR

state 0

    (0) S' -> . prog
    (2) prog -> . subprogram
    (3) prog -> . headers subprogram
    (10) subprogram -> . procedure
    (11) subprogram -> . function
    (4) headers -> . headers header
    (5) headers -> . header
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (12) function -> . IDENT
    (6) header -> . WITH pkg SEMICOLON
    (7) header -> . WITH pkg SEMICOLON USE pkg SEMICOLON

    PROC            shift and go to state 7
    IDENT           shift and go to state 8
    WITH            shift and go to state 9

    prog                           shift and go to state 1
    subprogram                     shift and go to state 2
    headers                        shift and go to state 3
    procedure                      shift and go to state 4
    function                       shift and go to state 5
    header                         shift and go to state 6

state 1

    (0) S' -> prog .



state 2

    (2) prog -> subprogram .

    $end            reduce using rule 2 (prog -> subprogram .)


state 3

    (3) prog -> headers . subprogram
    (4) headers -> headers . header
    (10) subprogram -> . procedure
    (11) subprogram -> . function
    (6) header -> . WITH pkg SEMICOLON
    (7) header -> . WITH pkg SEMICOLON USE pkg SEMICOLON
    (13) procedure -> . PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (12) function -> . IDENT

    WITH            shift and go to state 9
    PROC            shift and go to state 7
    IDENT           shift and go to state 8

    subprogram                     shift and go to state 10
    header                         shift and go to state 11
    procedure                      shift and go to state 4
    function                       shift and go to state 5

state 4

    (10) subprogram -> procedure .

    $end            reduce using rule 10 (subprogram -> procedure .)


state 5

    (11) subprogram -> function .

    $end            reduce using rule 11 (subprogram -> function .)


state 6

    (5) headers -> header .

    WITH            reduce using rule 5 (headers -> header .)
    PROC            reduce using rule 5 (headers -> header .)
    IDENT           reduce using rule 5 (headers -> header .)


state 7

    (13) procedure -> PROC . IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON

    IDENT           shift and go to state 12


state 8

    (12) function -> IDENT .

    $end            reduce using rule 12 (function -> IDENT .)


state 9

    (6) header -> WITH . pkg SEMICOLON
    (7) header -> WITH . pkg SEMICOLON USE pkg SEMICOLON
    (8) pkg -> . pkg DOT IDENT
    (9) pkg -> . IDENT

    IDENT           shift and go to state 14

    pkg                            shift and go to state 13

state 10

    (3) prog -> headers subprogram .

    $end            reduce using rule 3 (prog -> headers subprogram .)


state 11

    (4) headers -> headers header .

    WITH            reduce using rule 4 (headers -> headers header .)
    PROC            reduce using rule 4 (headers -> headers header .)
    IDENT           reduce using rule 4 (headers -> headers header .)


state 12

    (13) procedure -> PROC IDENT . args_opt IS declarations BEGIN statements END IDENT SEMICOLON
    (14) args_opt -> . LEFT_PAR args RIGHT_PAR
    (15) args_opt -> . empty
    (1) empty -> .

    LEFT_PAR        shift and go to state 16
    IS              reduce using rule 1 (empty -> .)

    args_opt                       shift and go to state 15
    empty                          shift and go to state 17

state 13

    (6) header -> WITH pkg . SEMICOLON
    (7) header -> WITH pkg . SEMICOLON USE pkg SEMICOLON
    (8) pkg -> pkg . DOT IDENT

    SEMICOLON       shift and go to state 18
    DOT             shift and go to state 19


state 14

    (9) pkg -> IDENT .

    SEMICOLON       reduce using rule 9 (pkg -> IDENT .)
    DOT             reduce using rule 9 (pkg -> IDENT .)


state 15

    (13) procedure -> PROC IDENT args_opt . IS declarations BEGIN statements END IDENT SEMICOLON

    IS              shift and go to state 20


state 16

    (14) args_opt -> LEFT_PAR . args RIGHT_PAR
    (16) args -> . args COMMA arg
    (17) args -> . arg
    (18) arg -> . IDENT COLON type

    IDENT           shift and go to state 23

    args                           shift and go to state 21
    arg                            shift and go to state 22

state 17

    (15) args_opt -> empty .

    IS              reduce using rule 15 (args_opt -> empty .)


state 18

    (6) header -> WITH pkg SEMICOLON .
    (7) header -> WITH pkg SEMICOLON . USE pkg SEMICOLON

    WITH            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    PROC            reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    IDENT           reduce using rule 6 (header -> WITH pkg SEMICOLON .)
    USE             shift and go to state 24


state 19

    (8) pkg -> pkg DOT . IDENT

    IDENT           shift and go to state 25


state 20

    (13) procedure -> PROC IDENT args_opt IS . declarations BEGIN statements END IDENT SEMICOLON
    (22) declarations -> . declarations declaration
    (23) declarations -> . declaration
    (24) declaration -> . IDENT COLON type ASSIGN value SEMICOLON

    IDENT           shift and go to state 26

    declarations                   shift and go to state 27
    declaration                    shift and go to state 28

state 21

    (14) args_opt -> LEFT_PAR args . RIGHT_PAR
    (16) args -> args . COMMA arg

    RIGHT_PAR       shift and go to state 29
    COMMA           shift and go to state 30


state 22

    (17) args -> arg .

    RIGHT_PAR       reduce using rule 17 (args -> arg .)
    COMMA           reduce using rule 17 (args -> arg .)


state 23

    (18) arg -> IDENT . COLON type

    COLON           shift and go to state 31


state 24

    (7) header -> WITH pkg SEMICOLON USE . pkg SEMICOLON
    (8) pkg -> . pkg DOT IDENT
    (9) pkg -> . IDENT

    IDENT           shift and go to state 14

    pkg                            shift and go to state 32

state 25

    (8) pkg -> pkg DOT IDENT .

    SEMICOLON       reduce using rule 8 (pkg -> pkg DOT IDENT .)
    DOT             reduce using rule 8 (pkg -> pkg DOT IDENT .)


state 26

    (24) declaration -> IDENT . COLON type ASSIGN value SEMICOLON

    COLON           shift and go to state 33


state 27

    (13) procedure -> PROC IDENT args_opt IS declarations . BEGIN statements END IDENT SEMICOLON
    (22) declarations -> declarations . declaration
    (24) declaration -> . IDENT COLON type ASSIGN value SEMICOLON

    BEGIN           shift and go to state 34
    IDENT           shift and go to state 26

    declaration                    shift and go to state 35

state 28

    (23) declarations -> declaration .

    BEGIN           reduce using rule 23 (declarations -> declaration .)
    IDENT           reduce using rule 23 (declarations -> declaration .)


state 29

    (14) args_opt -> LEFT_PAR args RIGHT_PAR .

    IS              reduce using rule 14 (args_opt -> LEFT_PAR args RIGHT_PAR .)


state 30

    (16) args -> args COMMA . arg
    (18) arg -> . IDENT COLON type

    IDENT           shift and go to state 23

    arg                            shift and go to state 36

state 31

    (18) arg -> IDENT COLON . type
    (19) type -> . TYPE_INT
    (20) type -> . TYPE_FLOAT
    (21) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_BOOL       shift and go to state 40

    type                           shift and go to state 37

state 32

    (7) header -> WITH pkg SEMICOLON USE pkg . SEMICOLON
    (8) pkg -> pkg . DOT IDENT

    SEMICOLON       shift and go to state 41
    DOT             shift and go to state 19


state 33

    (24) declaration -> IDENT COLON . type ASSIGN value SEMICOLON
    (19) type -> . TYPE_INT
    (20) type -> . TYPE_FLOAT
    (21) type -> . TYPE_BOOL

    TYPE_INT        shift and go to state 38
    TYPE_FLOAT      shift and go to state 39
    TYPE_BOOL       shift and go to state 40

    type                           shift and go to state 42

state 34

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN . statements END IDENT SEMICOLON
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statements                     shift and go to state 44
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 35

    (22) declarations -> declarations declaration .

    BEGIN           reduce using rule 22 (declarations -> declarations declaration .)
    IDENT           reduce using rule 22 (declarations -> declarations declaration .)


state 36

    (16) args -> args COMMA arg .

    RIGHT_PAR       reduce using rule 16 (args -> args COMMA arg .)
    COMMA           reduce using rule 16 (args -> args COMMA arg .)


state 37

    (18) arg -> IDENT COLON type .

    RIGHT_PAR       reduce using rule 18 (arg -> IDENT COLON type .)
    COMMA           reduce using rule 18 (arg -> IDENT COLON type .)


state 38

    (19) type -> TYPE_INT .

    RIGHT_PAR       reduce using rule 19 (type -> TYPE_INT .)
    COMMA           reduce using rule 19 (type -> TYPE_INT .)
    ASSIGN          reduce using rule 19 (type -> TYPE_INT .)


state 39

    (20) type -> TYPE_FLOAT .

    RIGHT_PAR       reduce using rule 20 (type -> TYPE_FLOAT .)
    COMMA           reduce using rule 20 (type -> TYPE_FLOAT .)
    ASSIGN          reduce using rule 20 (type -> TYPE_FLOAT .)


state 40

    (21) type -> TYPE_BOOL .

    RIGHT_PAR       reduce using rule 21 (type -> TYPE_BOOL .)
    COMMA           reduce using rule 21 (type -> TYPE_BOOL .)
    ASSIGN          reduce using rule 21 (type -> TYPE_BOOL .)


state 41

    (7) header -> WITH pkg SEMICOLON USE pkg SEMICOLON .

    WITH            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)
    PROC            reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)
    IDENT           reduce using rule 7 (header -> WITH pkg SEMICOLON USE pkg SEMICOLON .)


state 42

    (24) declaration -> IDENT COLON type . ASSIGN value SEMICOLON

    ASSIGN          shift and go to state 52


state 43

    (49) assign -> IDENT . ASSIGN value SEMICOLON

    ASSIGN          shift and go to state 53


state 44

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements . END IDENT SEMICOLON
    (44) statements -> statements . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    END             shift and go to state 54
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statement                      shift and go to state 55
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 45

    (45) statements -> statement .

    END             reduce using rule 45 (statements -> statement .)
    IDENT           reduce using rule 45 (statements -> statement .)
    IF              reduce using rule 45 (statements -> statement .)
    WHILE           reduce using rule 45 (statements -> statement .)
    FOR             reduce using rule 45 (statements -> statement .)
    ELSE            reduce using rule 45 (statements -> statement .)
    ELSIF           reduce using rule 45 (statements -> statement .)


state 46

    (46) statement -> assign .

    END             reduce using rule 46 (statement -> assign .)
    IDENT           reduce using rule 46 (statement -> assign .)
    IF              reduce using rule 46 (statement -> assign .)
    WHILE           reduce using rule 46 (statement -> assign .)
    FOR             reduce using rule 46 (statement -> assign .)
    ELSE            reduce using rule 46 (statement -> assign .)
    ELSIF           reduce using rule 46 (statement -> assign .)


state 47

    (47) statement -> if .

    END             reduce using rule 47 (statement -> if .)
    IDENT           reduce using rule 47 (statement -> if .)
    IF              reduce using rule 47 (statement -> if .)
    WHILE           reduce using rule 47 (statement -> if .)
    FOR             reduce using rule 47 (statement -> if .)
    ELSE            reduce using rule 47 (statement -> if .)
    ELSIF           reduce using rule 47 (statement -> if .)


state 48

    (48) statement -> loop .

    END             reduce using rule 48 (statement -> loop .)
    IDENT           reduce using rule 48 (statement -> loop .)
    IF              reduce using rule 48 (statement -> loop .)
    WHILE           reduce using rule 48 (statement -> loop .)
    FOR             reduce using rule 48 (statement -> loop .)
    ELSE            reduce using rule 48 (statement -> loop .)
    ELSIF           reduce using rule 48 (statement -> loop .)


state 49

    (50) if -> IF . bool_expr THEN statements elsifs else END IF SEMICOLON
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 60
    BOOL_VAL        shift and go to state 61
    IDENT           shift and go to state 62

    bool_expr                      shift and go to state 56
    bool_term                      shift and go to state 57
    bool                           shift and go to state 59

state 50

    (56) loop -> WHILE . bool_expr loop_body
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 60
    BOOL_VAL        shift and go to state 61
    IDENT           shift and go to state 62

    bool_expr                      shift and go to state 63
    bool_term                      shift and go to state 57
    bool                           shift and go to state 59

state 51

    (57) loop -> FOR . IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> FOR . IDENT OF IDENT loop_body

    IDENT           shift and go to state 64


state 52

    (24) declaration -> IDENT COLON type ASSIGN . value SEMICOLON
    (25) value -> . expr
    (26) value -> . bool_expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 71
    IDENT           shift and go to state 65
    NUMBER          shift and go to state 72
    BOOL_VAL        shift and go to state 61

    value                          shift and go to state 66
    expr                           shift and go to state 67
    bool_expr                      shift and go to state 68
    term                           shift and go to state 69
    bool_term                      shift and go to state 57
    factor                         shift and go to state 70
    bool                           shift and go to state 59

state 53

    (49) assign -> IDENT ASSIGN . value SEMICOLON
    (25) value -> . expr
    (26) value -> . bool_expr
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 71
    IDENT           shift and go to state 65
    NUMBER          shift and go to state 72
    BOOL_VAL        shift and go to state 61

    value                          shift and go to state 73
    expr                           shift and go to state 67
    bool_expr                      shift and go to state 68
    term                           shift and go to state 69
    bool_term                      shift and go to state 57
    factor                         shift and go to state 70
    bool                           shift and go to state 59

state 54

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END . IDENT SEMICOLON

    IDENT           shift and go to state 74


state 55

    (44) statements -> statements statement .

    END             reduce using rule 44 (statements -> statements statement .)
    IDENT           reduce using rule 44 (statements -> statements statement .)
    IF              reduce using rule 44 (statements -> statements statement .)
    WHILE           reduce using rule 44 (statements -> statements statement .)
    FOR             reduce using rule 44 (statements -> statements statement .)
    ELSE            reduce using rule 44 (statements -> statements statement .)
    ELSIF           reduce using rule 44 (statements -> statements statement .)


state 56

    (50) if -> IF bool_expr . THEN statements elsifs else END IF SEMICOLON

    THEN            shift and go to state 75


state 57

    (36) bool_expr -> bool_term . AND bool_term
    (37) bool_expr -> bool_term . OR bool_term
    (38) bool_expr -> bool_term .

    AND             shift and go to state 76
    OR              shift and go to state 77
    THEN            reduce using rule 38 (bool_expr -> bool_term .)
    LOOP            reduce using rule 38 (bool_expr -> bool_term .)
    SEMICOLON       reduce using rule 38 (bool_expr -> bool_term .)
    RIGHT_PAR       reduce using rule 38 (bool_expr -> bool_term .)


state 58

    (39) bool_term -> NOT . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    LEFT_PAR        shift and go to state 60
    BOOL_VAL        shift and go to state 61
    IDENT           shift and go to state 62

    bool                           shift and go to state 78

state 59

    (40) bool_term -> bool .

    AND             reduce using rule 40 (bool_term -> bool .)
    OR              reduce using rule 40 (bool_term -> bool .)
    THEN            reduce using rule 40 (bool_term -> bool .)
    LOOP            reduce using rule 40 (bool_term -> bool .)
    SEMICOLON       reduce using rule 40 (bool_term -> bool .)
    RIGHT_PAR       reduce using rule 40 (bool_term -> bool .)


state 60

    (41) bool -> LEFT_PAR . bool_expr RIGHT_PAR
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 60
    BOOL_VAL        shift and go to state 61
    IDENT           shift and go to state 62

    bool_expr                      shift and go to state 79
    bool_term                      shift and go to state 57
    bool                           shift and go to state 59

state 61

    (42) bool -> BOOL_VAL .

    AND             reduce using rule 42 (bool -> BOOL_VAL .)
    OR              reduce using rule 42 (bool -> BOOL_VAL .)
    THEN            reduce using rule 42 (bool -> BOOL_VAL .)
    LOOP            reduce using rule 42 (bool -> BOOL_VAL .)
    SEMICOLON       reduce using rule 42 (bool -> BOOL_VAL .)
    RIGHT_PAR       reduce using rule 42 (bool -> BOOL_VAL .)


state 62

    (43) bool -> IDENT .

    AND             reduce using rule 43 (bool -> IDENT .)
    OR              reduce using rule 43 (bool -> IDENT .)
    THEN            reduce using rule 43 (bool -> IDENT .)
    LOOP            reduce using rule 43 (bool -> IDENT .)
    SEMICOLON       reduce using rule 43 (bool -> IDENT .)
    RIGHT_PAR       reduce using rule 43 (bool -> IDENT .)


state 63

    (56) loop -> WHILE bool_expr . loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON

    LOOP            shift and go to state 81

    loop_body                      shift and go to state 80

state 64

    (57) loop -> FOR IDENT . IN expr DUB_DOT expr loop_body
    (58) loop -> FOR IDENT . OF IDENT loop_body

    IN              shift and go to state 82
    OF              shift and go to state 83


state 65

    (34) factor -> IDENT .
    (43) bool -> IDENT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 34 (factor -> IDENT .)
  ! reduce/reduce conflict for RIGHT_PAR resolved using rule 34 (factor -> IDENT .)
    MUL             reduce using rule 34 (factor -> IDENT .)
    DIV             reduce using rule 34 (factor -> IDENT .)
    PLUS            reduce using rule 34 (factor -> IDENT .)
    MINUS           reduce using rule 34 (factor -> IDENT .)
    SEMICOLON       reduce using rule 34 (factor -> IDENT .)
    RIGHT_PAR       reduce using rule 34 (factor -> IDENT .)
    AND             reduce using rule 43 (bool -> IDENT .)
    OR              reduce using rule 43 (bool -> IDENT .)

  ! SEMICOLON       [ reduce using rule 43 (bool -> IDENT .) ]
  ! RIGHT_PAR       [ reduce using rule 43 (bool -> IDENT .) ]


state 66

    (24) declaration -> IDENT COLON type ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 84


state 67

    (25) value -> expr .
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    SEMICOLON       reduce using rule 25 (value -> expr .)
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86


state 68

    (26) value -> bool_expr .

    SEMICOLON       reduce using rule 26 (value -> bool_expr .)


state 69

    (29) expr -> term .
    (30) term -> term . MUL factor
    (31) term -> term . DIV factor

    PLUS            reduce using rule 29 (expr -> term .)
    MINUS           reduce using rule 29 (expr -> term .)
    SEMICOLON       reduce using rule 29 (expr -> term .)
    RIGHT_PAR       reduce using rule 29 (expr -> term .)
    DUB_DOT         reduce using rule 29 (expr -> term .)
    LOOP            reduce using rule 29 (expr -> term .)
    MUL             shift and go to state 87
    DIV             shift and go to state 88


state 70

    (32) term -> factor .

    MUL             reduce using rule 32 (term -> factor .)
    DIV             reduce using rule 32 (term -> factor .)
    PLUS            reduce using rule 32 (term -> factor .)
    MINUS           reduce using rule 32 (term -> factor .)
    SEMICOLON       reduce using rule 32 (term -> factor .)
    RIGHT_PAR       reduce using rule 32 (term -> factor .)
    DUB_DOT         reduce using rule 32 (term -> factor .)
    LOOP            reduce using rule 32 (term -> factor .)


state 71

    (33) factor -> LEFT_PAR . expr RIGHT_PAR
    (41) bool -> LEFT_PAR . bool_expr RIGHT_PAR
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 71
    IDENT           shift and go to state 65
    NUMBER          shift and go to state 72
    BOOL_VAL        shift and go to state 61

    expr                           shift and go to state 89
    bool_expr                      shift and go to state 79
    term                           shift and go to state 69
    bool_term                      shift and go to state 57
    factor                         shift and go to state 70
    bool                           shift and go to state 59

state 72

    (35) factor -> NUMBER .

    MUL             reduce using rule 35 (factor -> NUMBER .)
    DIV             reduce using rule 35 (factor -> NUMBER .)
    PLUS            reduce using rule 35 (factor -> NUMBER .)
    MINUS           reduce using rule 35 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 35 (factor -> NUMBER .)
    RIGHT_PAR       reduce using rule 35 (factor -> NUMBER .)
    DUB_DOT         reduce using rule 35 (factor -> NUMBER .)
    LOOP            reduce using rule 35 (factor -> NUMBER .)


state 73

    (49) assign -> IDENT ASSIGN value . SEMICOLON

    SEMICOLON       shift and go to state 90


state 74

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT . SEMICOLON

    SEMICOLON       shift and go to state 91


state 75

    (50) if -> IF bool_expr THEN . statements elsifs else END IF SEMICOLON
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statements                     shift and go to state 92
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 76

    (36) bool_expr -> bool_term AND . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 60
    BOOL_VAL        shift and go to state 61
    IDENT           shift and go to state 62

    bool_term                      shift and go to state 93
    bool                           shift and go to state 59

state 77

    (37) bool_expr -> bool_term OR . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 60
    BOOL_VAL        shift and go to state 61
    IDENT           shift and go to state 62

    bool_term                      shift and go to state 94
    bool                           shift and go to state 59

state 78

    (39) bool_term -> NOT bool .

    AND             reduce using rule 39 (bool_term -> NOT bool .)
    OR              reduce using rule 39 (bool_term -> NOT bool .)
    THEN            reduce using rule 39 (bool_term -> NOT bool .)
    LOOP            reduce using rule 39 (bool_term -> NOT bool .)
    SEMICOLON       reduce using rule 39 (bool_term -> NOT bool .)
    RIGHT_PAR       reduce using rule 39 (bool_term -> NOT bool .)


state 79

    (41) bool -> LEFT_PAR bool_expr . RIGHT_PAR

    RIGHT_PAR       shift and go to state 95


state 80

    (56) loop -> WHILE bool_expr loop_body .

    END             reduce using rule 56 (loop -> WHILE bool_expr loop_body .)
    IDENT           reduce using rule 56 (loop -> WHILE bool_expr loop_body .)
    IF              reduce using rule 56 (loop -> WHILE bool_expr loop_body .)
    WHILE           reduce using rule 56 (loop -> WHILE bool_expr loop_body .)
    FOR             reduce using rule 56 (loop -> WHILE bool_expr loop_body .)
    ELSE            reduce using rule 56 (loop -> WHILE bool_expr loop_body .)
    ELSIF           reduce using rule 56 (loop -> WHILE bool_expr loop_body .)


state 81

    (59) loop_body -> LOOP . statements END LOOP SEMICOLON
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statements                     shift and go to state 96
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 82

    (57) loop -> FOR IDENT IN . expr DUB_DOT expr loop_body
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 99
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 72

    expr                           shift and go to state 98
    term                           shift and go to state 69
    factor                         shift and go to state 70

state 83

    (58) loop -> FOR IDENT OF . IDENT loop_body

    IDENT           shift and go to state 100


state 84

    (24) declaration -> IDENT COLON type ASSIGN value SEMICOLON .

    BEGIN           reduce using rule 24 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)
    IDENT           reduce using rule 24 (declaration -> IDENT COLON type ASSIGN value SEMICOLON .)


state 85

    (27) expr -> expr PLUS . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 99
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 72

    term                           shift and go to state 101
    factor                         shift and go to state 70

state 86

    (28) expr -> expr MINUS . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 99
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 72

    term                           shift and go to state 102
    factor                         shift and go to state 70

state 87

    (30) term -> term MUL . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 99
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 72

    factor                         shift and go to state 103

state 88

    (31) term -> term DIV . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 99
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 72

    factor                         shift and go to state 104

state 89

    (33) factor -> LEFT_PAR expr . RIGHT_PAR
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    RIGHT_PAR       shift and go to state 105
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86


state 90

    (49) assign -> IDENT ASSIGN value SEMICOLON .

    END             reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    IDENT           reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    IF              reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    WHILE           reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    FOR             reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    ELSE            reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)
    ELSIF           reduce using rule 49 (assign -> IDENT ASSIGN value SEMICOLON .)


state 91

    (13) procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .

    $end            reduce using rule 13 (procedure -> PROC IDENT args_opt IS declarations BEGIN statements END IDENT SEMICOLON .)


state 92

    (50) if -> IF bool_expr THEN statements . elsifs else END IF SEMICOLON
    (44) statements -> statements . statement
    (51) elsifs -> . elsifs elsif
    (52) elsifs -> . empty
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (1) empty -> .
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    ELSE            reduce using rule 1 (empty -> .)
    ELSIF           reduce using rule 1 (empty -> .)
    END             reduce using rule 1 (empty -> .)
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    elsifs                         shift and go to state 106
    statement                      shift and go to state 55
    empty                          shift and go to state 107
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 93

    (36) bool_expr -> bool_term AND bool_term .

    THEN            reduce using rule 36 (bool_expr -> bool_term AND bool_term .)
    LOOP            reduce using rule 36 (bool_expr -> bool_term AND bool_term .)
    SEMICOLON       reduce using rule 36 (bool_expr -> bool_term AND bool_term .)
    RIGHT_PAR       reduce using rule 36 (bool_expr -> bool_term AND bool_term .)


state 94

    (37) bool_expr -> bool_term OR bool_term .

    THEN            reduce using rule 37 (bool_expr -> bool_term OR bool_term .)
    LOOP            reduce using rule 37 (bool_expr -> bool_term OR bool_term .)
    SEMICOLON       reduce using rule 37 (bool_expr -> bool_term OR bool_term .)
    RIGHT_PAR       reduce using rule 37 (bool_expr -> bool_term OR bool_term .)


state 95

    (41) bool -> LEFT_PAR bool_expr RIGHT_PAR .

    AND             reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    OR              reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    THEN            reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    LOOP            reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 41 (bool -> LEFT_PAR bool_expr RIGHT_PAR .)


state 96

    (59) loop_body -> LOOP statements . END LOOP SEMICOLON
    (44) statements -> statements . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    END             shift and go to state 108
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statement                      shift and go to state 55
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 97

    (34) factor -> IDENT .

    MUL             reduce using rule 34 (factor -> IDENT .)
    DIV             reduce using rule 34 (factor -> IDENT .)
    DUB_DOT         reduce using rule 34 (factor -> IDENT .)
    PLUS            reduce using rule 34 (factor -> IDENT .)
    MINUS           reduce using rule 34 (factor -> IDENT .)
    SEMICOLON       reduce using rule 34 (factor -> IDENT .)
    RIGHT_PAR       reduce using rule 34 (factor -> IDENT .)
    LOOP            reduce using rule 34 (factor -> IDENT .)


state 98

    (57) loop -> FOR IDENT IN expr . DUB_DOT expr loop_body
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term

    DUB_DOT         shift and go to state 109
    PLUS            shift and go to state 85
    MINUS           shift and go to state 86


state 99

    (33) factor -> LEFT_PAR . expr RIGHT_PAR
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 99
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 72

    expr                           shift and go to state 89
    term                           shift and go to state 69
    factor                         shift and go to state 70

state 100

    (58) loop -> FOR IDENT OF IDENT . loop_body
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON

    LOOP            shift and go to state 81

    loop_body                      shift and go to state 110

state 101

    (27) expr -> expr PLUS term .
    (30) term -> term . MUL factor
    (31) term -> term . DIV factor

    PLUS            reduce using rule 27 (expr -> expr PLUS term .)
    MINUS           reduce using rule 27 (expr -> expr PLUS term .)
    SEMICOLON       reduce using rule 27 (expr -> expr PLUS term .)
    RIGHT_PAR       reduce using rule 27 (expr -> expr PLUS term .)
    DUB_DOT         reduce using rule 27 (expr -> expr PLUS term .)
    LOOP            reduce using rule 27 (expr -> expr PLUS term .)
    MUL             shift and go to state 87
    DIV             shift and go to state 88


state 102

    (28) expr -> expr MINUS term .
    (30) term -> term . MUL factor
    (31) term -> term . DIV factor

    PLUS            reduce using rule 28 (expr -> expr MINUS term .)
    MINUS           reduce using rule 28 (expr -> expr MINUS term .)
    SEMICOLON       reduce using rule 28 (expr -> expr MINUS term .)
    RIGHT_PAR       reduce using rule 28 (expr -> expr MINUS term .)
    DUB_DOT         reduce using rule 28 (expr -> expr MINUS term .)
    LOOP            reduce using rule 28 (expr -> expr MINUS term .)
    MUL             shift and go to state 87
    DIV             shift and go to state 88


state 103

    (30) term -> term MUL factor .

    MUL             reduce using rule 30 (term -> term MUL factor .)
    DIV             reduce using rule 30 (term -> term MUL factor .)
    PLUS            reduce using rule 30 (term -> term MUL factor .)
    MINUS           reduce using rule 30 (term -> term MUL factor .)
    SEMICOLON       reduce using rule 30 (term -> term MUL factor .)
    RIGHT_PAR       reduce using rule 30 (term -> term MUL factor .)
    DUB_DOT         reduce using rule 30 (term -> term MUL factor .)
    LOOP            reduce using rule 30 (term -> term MUL factor .)


state 104

    (31) term -> term DIV factor .

    MUL             reduce using rule 31 (term -> term DIV factor .)
    DIV             reduce using rule 31 (term -> term DIV factor .)
    PLUS            reduce using rule 31 (term -> term DIV factor .)
    MINUS           reduce using rule 31 (term -> term DIV factor .)
    SEMICOLON       reduce using rule 31 (term -> term DIV factor .)
    RIGHT_PAR       reduce using rule 31 (term -> term DIV factor .)
    DUB_DOT         reduce using rule 31 (term -> term DIV factor .)
    LOOP            reduce using rule 31 (term -> term DIV factor .)


state 105

    (33) factor -> LEFT_PAR expr RIGHT_PAR .

    MUL             reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    DIV             reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    PLUS            reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    MINUS           reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    SEMICOLON       reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    RIGHT_PAR       reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    DUB_DOT         reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)
    LOOP            reduce using rule 33 (factor -> LEFT_PAR expr RIGHT_PAR .)


state 106

    (50) if -> IF bool_expr THEN statements elsifs . else END IF SEMICOLON
    (51) elsifs -> elsifs . elsif
    (54) else -> . ELSE statements
    (55) else -> . empty
    (53) elsif -> . ELSIF bool_expr THEN statements
    (1) empty -> .

    ELSE            shift and go to state 113
    ELSIF           shift and go to state 115
    END             reduce using rule 1 (empty -> .)

    else                           shift and go to state 111
    elsif                          shift and go to state 112
    empty                          shift and go to state 114

state 107

    (52) elsifs -> empty .

    ELSE            reduce using rule 52 (elsifs -> empty .)
    ELSIF           reduce using rule 52 (elsifs -> empty .)
    END             reduce using rule 52 (elsifs -> empty .)


state 108

    (59) loop_body -> LOOP statements END . LOOP SEMICOLON

    LOOP            shift and go to state 116


state 109

    (57) loop -> FOR IDENT IN expr DUB_DOT . expr loop_body
    (27) expr -> . expr PLUS term
    (28) expr -> . expr MINUS term
    (29) expr -> . term
    (30) term -> . term MUL factor
    (31) term -> . term DIV factor
    (32) term -> . factor
    (33) factor -> . LEFT_PAR expr RIGHT_PAR
    (34) factor -> . IDENT
    (35) factor -> . NUMBER

    LEFT_PAR        shift and go to state 99
    IDENT           shift and go to state 97
    NUMBER          shift and go to state 72

    expr                           shift and go to state 117
    term                           shift and go to state 69
    factor                         shift and go to state 70

state 110

    (58) loop -> FOR IDENT OF IDENT loop_body .

    END             reduce using rule 58 (loop -> FOR IDENT OF IDENT loop_body .)
    IDENT           reduce using rule 58 (loop -> FOR IDENT OF IDENT loop_body .)
    IF              reduce using rule 58 (loop -> FOR IDENT OF IDENT loop_body .)
    WHILE           reduce using rule 58 (loop -> FOR IDENT OF IDENT loop_body .)
    FOR             reduce using rule 58 (loop -> FOR IDENT OF IDENT loop_body .)
    ELSE            reduce using rule 58 (loop -> FOR IDENT OF IDENT loop_body .)
    ELSIF           reduce using rule 58 (loop -> FOR IDENT OF IDENT loop_body .)


state 111

    (50) if -> IF bool_expr THEN statements elsifs else . END IF SEMICOLON

    END             shift and go to state 118


state 112

    (51) elsifs -> elsifs elsif .

    ELSE            reduce using rule 51 (elsifs -> elsifs elsif .)
    ELSIF           reduce using rule 51 (elsifs -> elsifs elsif .)
    END             reduce using rule 51 (elsifs -> elsifs elsif .)


state 113

    (54) else -> ELSE . statements
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statements                     shift and go to state 119
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 114

    (55) else -> empty .

    END             reduce using rule 55 (else -> empty .)


state 115

    (53) elsif -> ELSIF . bool_expr THEN statements
    (36) bool_expr -> . bool_term AND bool_term
    (37) bool_expr -> . bool_term OR bool_term
    (38) bool_expr -> . bool_term
    (39) bool_term -> . NOT bool
    (40) bool_term -> . bool
    (41) bool -> . LEFT_PAR bool_expr RIGHT_PAR
    (42) bool -> . BOOL_VAL
    (43) bool -> . IDENT

    NOT             shift and go to state 58
    LEFT_PAR        shift and go to state 60
    BOOL_VAL        shift and go to state 61
    IDENT           shift and go to state 62

    bool_expr                      shift and go to state 120
    bool_term                      shift and go to state 57
    bool                           shift and go to state 59

state 116

    (59) loop_body -> LOOP statements END LOOP . SEMICOLON

    SEMICOLON       shift and go to state 121


state 117

    (57) loop -> FOR IDENT IN expr DUB_DOT expr . loop_body
    (27) expr -> expr . PLUS term
    (28) expr -> expr . MINUS term
    (59) loop_body -> . LOOP statements END LOOP SEMICOLON

    PLUS            shift and go to state 85
    MINUS           shift and go to state 86
    LOOP            shift and go to state 81

    loop_body                      shift and go to state 122

state 118

    (50) if -> IF bool_expr THEN statements elsifs else END . IF SEMICOLON

    IF              shift and go to state 123


state 119

    (54) else -> ELSE statements .
    (44) statements -> statements . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    END             reduce using rule 54 (else -> ELSE statements .)
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statement                      shift and go to state 55
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 120

    (53) elsif -> ELSIF bool_expr . THEN statements

    THEN            shift and go to state 124


state 121

    (59) loop_body -> LOOP statements END LOOP SEMICOLON .

    END             reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    IDENT           reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    IF              reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    WHILE           reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    FOR             reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    ELSE            reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)
    ELSIF           reduce using rule 59 (loop_body -> LOOP statements END LOOP SEMICOLON .)


state 122

    (57) loop -> FOR IDENT IN expr DUB_DOT expr loop_body .

    END             reduce using rule 57 (loop -> FOR IDENT IN expr DUB_DOT expr loop_body .)
    IDENT           reduce using rule 57 (loop -> FOR IDENT IN expr DUB_DOT expr loop_body .)
    IF              reduce using rule 57 (loop -> FOR IDENT IN expr DUB_DOT expr loop_body .)
    WHILE           reduce using rule 57 (loop -> FOR IDENT IN expr DUB_DOT expr loop_body .)
    FOR             reduce using rule 57 (loop -> FOR IDENT IN expr DUB_DOT expr loop_body .)
    ELSE            reduce using rule 57 (loop -> FOR IDENT IN expr DUB_DOT expr loop_body .)
    ELSIF           reduce using rule 57 (loop -> FOR IDENT IN expr DUB_DOT expr loop_body .)


state 123

    (50) if -> IF bool_expr THEN statements elsifs else END IF . SEMICOLON

    SEMICOLON       shift and go to state 125


state 124

    (53) elsif -> ELSIF bool_expr THEN . statements
    (44) statements -> . statements statement
    (45) statements -> . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statements                     shift and go to state 126
    statement                      shift and go to state 45
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48

state 125

    (50) if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .

    END             reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    IDENT           reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    IF              reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    WHILE           reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    FOR             reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    ELSE            reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)
    ELSIF           reduce using rule 50 (if -> IF bool_expr THEN statements elsifs else END IF SEMICOLON .)


state 126

    (53) elsif -> ELSIF bool_expr THEN statements .
    (44) statements -> statements . statement
    (46) statement -> . assign
    (47) statement -> . if
    (48) statement -> . loop
    (49) assign -> . IDENT ASSIGN value SEMICOLON
    (50) if -> . IF bool_expr THEN statements elsifs else END IF SEMICOLON
    (56) loop -> . WHILE bool_expr loop_body
    (57) loop -> . FOR IDENT IN expr DUB_DOT expr loop_body
    (58) loop -> . FOR IDENT OF IDENT loop_body

    ELSE            reduce using rule 53 (elsif -> ELSIF bool_expr THEN statements .)
    ELSIF           reduce using rule 53 (elsif -> ELSIF bool_expr THEN statements .)
    END             reduce using rule 53 (elsif -> ELSIF bool_expr THEN statements .)
    IDENT           shift and go to state 43
    IF              shift and go to state 49
    WHILE           shift and go to state 50
    FOR             shift and go to state 51

    statement                      shift and go to state 55
    assign                         shift and go to state 46
    if                             shift and go to state 47
    loop                           shift and go to state 48
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 65 resolved using rule (factor -> IDENT)
WARNING: rejected rule (bool -> IDENT) in state 65
